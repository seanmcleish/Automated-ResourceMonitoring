module Main {

modulepar {
  charstring serviceHostName := "localhost";
  integer servicePort := 8090;
  charstring sensorHostName := "localhost";
  integer sensorPort := 10005;
}

const charstring connectionString := serviceHostName &":"&int2str(servicePort);

type record regressionParameter
{
  float slopeParameter,		// Steigung
  float interceptParameter 	// Niveau
}

type record of float floatValues;
type record of integer integerValues;
type union Values
{
  floatValues valuesAsFloat,
  integerValues valuesAsInteger
}

import from rmplugin all;
import from HTTPmsg_Types all;
import from HTTPmsg_PortType all;
type component TestComponent 
{
	port HTTPmsg_PT TestPort;
}

function SendRESTRequest(in template HTTPMessage t_request) runs on TestComponent return JSONObject
{
  	map(self:TestPort, system:TestPort);
    var Connect_result v_Connect_result;
    var HTTPMessage  v_HTTPMessage_response;
    template Close t_close := { client_id := omit}
    template Connect t_connect := { hostname := serviceHostName, portnumber := servicePort, use_ssl := false };
    var integer v_http_client_id;
    var JSONObject v_JSON_PDU;
    
    log(t_request.request.header)
   
    timer t0:=3.0;    
    //Connect
    TestPort.send(t_connect) ;
    t0.start;
    alt 
    {
      []TestPort.receive(Connect_result:?) -> value v_Connect_result { v_http_client_id:=v_Connect_result.client_id}
      []t0.timeout { }
  
    }
    
    TestPort.send(t_request)

    alt 
    {
      []TestPort.receive(HTTPMessage:?)  -> value v_HTTPMessage_response
      {
        if (ischosen(v_HTTPMessage_response.response_binary))
        {
          v_JSON_PDU := dec_JSON(v_HTTPMessage_response.response_binary.body);
        }
        if (ischosen(v_HTTPMessage_response.response))
        {
          v_JSON_PDU := dec_JSON(char2oct(v_HTTPMessage_response.response.body));
        }
      }
    }
    //Close
    TestPort.send(t_close) 
    t0.start;
    alt 
    {
      []TestPort.receive {}
      []t0.timeout {}
    }
    
  	all component.kill;
	return v_JSON_PDU;
}

function ContentLength (in charstring par_body) return charstring
{
  var charstring a:=int2str(lengthof (par_body))
  return a;
}

function calculateRegression (inout Values values) return regressionParameter
{
  var float slope:=0.0;				// Steigung
  var float intercept:=0.0;			// Niveau
  var float averageCounter := 0.0;
  var float averageValue := 0.0;
  if(ischosen(values.valuesAsFloat))
  {
    if(lengthof(values.valuesAsFloat)<1)
    {
      slope := not_a_number;
      intercept := not_a_number;
    }
    else
    {
      for(var integer i := 0; i<lengthof(values.valuesAsFloat); i := i+1)
      {
        averageCounter := averageCounter + int2float(i);
        averageValue := averageValue + values.valuesAsFloat[i];
      }
      averageCounter := averageCounter / int2float(lengthof(values.valuesAsFloat));
      averageValue := averageValue / int2float(lengthof(values.valuesAsFloat));
      var float slope1 := 0.0;
      var float slope2 := 0.0;
      for(var integer i := 0; i<lengthof(values.valuesAsFloat); i := i+1)
      {
        slope1 := slope1 + (int2float(i)-averageCounter)*(values.valuesAsFloat[i]-averageValue);
        slope2 := slope2 + (int2float(i)-averageCounter)*(int2float(i)-averageCounter);
      }
      slope := slope1/slope2;
      intercept := averageValue-slope*averageCounter;
      }

  }
  else if(ischosen(values.valuesAsInteger))
  {
    if(lengthof(values.valuesAsInteger)<1)
    {
      slope := not_a_number;
      intercept := not_a_number;
    }
    else
    {
      for(var integer i := 0; i<lengthof(values.valuesAsInteger); i := i+1)
      {
        averageCounter := averageCounter + int2float(i);
        averageValue := averageValue + values.valuesAsFloat[i];
      }
      averageCounter := averageCounter / int2float(lengthof(values.valuesAsFloat));
      averageValue := averageValue / int2float(lengthof(values.valuesAsFloat));
      var float slope1 := 0.0;
      var float slope2 := 0.0;
      for(var integer i := 0; i<lengthof(values.valuesAsFloat); i := i+1)
      {
        slope1 := slope1 + (int2float(i)-averageCounter)*(values.valuesAsFloat[i]-averageValue);
        slope2 := slope2 + (int2float(i)-averageCounter)*(int2float(i)-averageCounter);
      }
      slope := slope1/slope2;
      intercept := averageValue-slope*averageCounter;
    }
  }
  else
  {
    slope := not_a_number;
    intercept := not_a_number;
  }
  return {slope, intercept};
}

testcase tc_createDataByHostname(out JSONObject.measurement result)
runs on TestComponent
{
  map(self:TestPort, system:TestPort);
  var template HTTPMessage post_request := t_POST_Request("/createDataByHostName?hostName="&sensorHostName&"&remotePort="&int2str(sensorPort), connectionString);
  
  var JSONObject response := SendRESTRequest(post_request);
  if(ischosen(response.measurement))
  {
    setverdict(pass);
    result:=response.measurement;
  }
  else
  {
    setverdict(none);
  }
}

testcase tc_createProcessWithMeasurementId(out JSONObject.measurement result)
runs on TestComponent
{
  map(self:TestPort, system:TestPort);
  var template HTTPMessage post_request := t_POST_Request("/createDataByHostName?hostName="&sensorHostName&"&remotePort="&int2str(sensorPort), connectionString);
  
  var JSONObject response := SendRESTRequest(post_request);
  if(ischosen(response.measurement))
  {
    setverdict(pass);
    result:=response.measurement;
  }
  else
  {
    setverdict(none);
  }
}

testcase tc_memoryUsageLowerThan(in integer measurementId, in integer memoryTotalSpace, in float relativeLowerBound) 
runs on TestComponent 
system TestComponent
{
  var template HTTPMessage get_request := t_GET_Request("/memory/"&int2str(memoryTotalSpace)&"/memoryValues/"&int2str(measurementId), connectionString);
  var JSONObject result := SendRESTRequest(get_request);
  setverdict(pass);
  for(var integer i := 0; i < lengthof(result.memoryValueList); i := i+1)
  {
    if((int2float(result.memoryValueList[i].memoryValueAvailable)/int2float(memoryTotalSpace)) < relativeLowerBound)
    {
      setverdict(fail);
    }
  }
}

testcase tc_processMemoryUsageGreaterThan(in integer measurementId, in integer memoryTotalSpace, in integer processId, in float relativeUpperBound)
runs on TestComponent 
system TestComponent
{
  var template HTTPMessage get_request := t_GET_Request("/process/" &int2str(processId)&"/processValues/" &int2str(measurementId), connectionString);
  var JSONObject result := SendRESTRequest(get_request);
  setverdict(pass);
  if(ischosen(result.nullable))
  {
    setverdict(none);
    stop;  
  }
  for(var integer i := 0; i<lengthof(result.processValueList); i := i+1)
  {
    if((int2float(result.processValueList[i].processValueResidentSetSize)/int2float(memoryTotalSpace)) > relativeUpperBound)
    {
      setverdict(fail);
      stop;
    }
  }
}
	control
    {
      var integer iterations := 0;
      //Create measurement
      var JSONObject.measurement measurement;
      var verdicttype v := execute(tc_createDataByHostname(measurement));
      if(v==none or v==error)
      {
        if(v==none)
        {
          log("Creating dataset by hostname failed. Received empty JSON-Response. Check parameters.");
        }
        else if(v == error)
        {
          log("Received error. Check if webservice is running on the given remote hostname and remote port.");
        }
        stop;
      }
      log("Created measurement: " & int2str(measurement.measurementId));
      //Add theprocess to be observed process to the measurement
      //Execute testcases
      label startTestcases;
      
      execute(tc_memoryUsageLowerThan(measurement.measurementId, 972238848, 0.20));
      execute(tc_processMemoryUsageGreaterThan(measurement.measurementId, 972238848, 6, 0.05));
      
      //Increased iterationscounter and repeat testcases until manually stopped
      iterations:=iterations+1;
      goto startTestcases;
    }
}

