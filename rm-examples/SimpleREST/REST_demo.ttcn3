/******************************************************************************
* Copyright (c) 2015, 2015  Ericsson AB
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
******************************************************************************/


/*
http://www.geoplugin.net/json.gp?ip=xx.xx.xx.xx

{
  "geoplugin_request":"89.147.71.240",
  "geoplugin_status":200,
  "geoplugin_credit":"Some of the returned data includes GeoLite data created by MaxMind, available from <a href=\\'http:\/\/www.maxmind.com\\'>http:\/\/www.maxmind.com<\/a>.",
  "geoplugin_city":"Part",
  "geoplugin_region":"Zala",
  "geoplugin_areaCode":"0",
  "geoplugin_dmaCode":"0",
  "geoplugin_countryCode":"HU",
  "geoplugin_countryName":"Hungary",
  "geoplugin_continentCode":"EU",
  "geoplugin_latitude":"46.549999",
  "geoplugin_longitude":"16.9167",
  "geoplugin_regionCode":"24",
  "geoplugin_regionName":"Zala",
  "geoplugin_currencyCode":"HUF",
  "geoplugin_currencySymbol":"&#70;&#116;",
  "geoplugin_currencySymbol_UTF8":"Ft",
  "geoplugin_currencyConverter":279.486
}


http://jsonschema.net/#/   JSON schema generator

*/

module REST_demo

{






modulepar {

  charstring  tsp_HostName:="www.geoplugin.net";
  integer     tsp_HttpPort    := 80;


  charstring  tsp_LocalHostName:="136.225.41.157";
  integer     tsp_LocalHttpPort    := 9998;




}

import from geoplugin all;
import from HTTPmsg_Types all;
import from HTTPmsg_PortType all;

type enumerated Http_state {active(0),passive(1)};


type component HTTP_CT {





  var Http_state v_http_state;
  var charstring vl_char,vl_char0



  //---------------------HTTP---------------------------
  var Connect_result vl_Connect_result
  var Connect vl_Connect  
  var Listen_result vl_Listen_result
  var Listen vl_Listen
  var Close vl_Close
  var Half_close vl_Half_close
  var Shutdown vl_Shutdown
  var Client_connected vl_Client_connected


  var HTTPMessage  vl_HTTPMessage
  var integer vl_http_client_id,vl_tcp_client_id

  var charstring vl_body;
  var octetstring  vl_body_bin;
  var boolean v_run




  //-----------------------------------------------------------------------------
  //ComponentTimers
  //-----------------------------------------------------------------------------  
  timer Tone;  

  //-----------------------------------------------------------------------------
  //ComponentPorts
  //-----------------------------------------------------------------------------  

  port HTTPmsg_PT        HTTP_PCO;


};





template JSON_PDU t_jsonTemplate :=
{
geoplugin_response:=
{
  geoplugin_request:="89.147.71.240",
  geoplugin_status:=200,
  geoplugin_credit:="AAAAAAAAAAAAAAA",
  geoplugin_city:="Part",
  geoplugin_region:="Zala",
  geoplugin_areaCode:="0",
  geoplugin_dmaCode:="0",
  geoplugin_countryCode:="HU",
  geoplugin_countryName:="Hungary",
  geoplugin_continentCode:="EU",
  geoplugin_latitude:="46.549999",
  geoplugin_longitude:="16.9167",
  geoplugin_regionCode:="24",
  geoplugin_regionName:="Zala",
  geoplugin_currencyCode:="HUF",
  geoplugin_currencySymbol:="&#70;&#116;",
  geoplugin_currencySymbol_UTF8:="Ft",
  geoplugin_currencyConverter:=300.0
}


}



template Listen t_Listen := { local_hostname := tsp_LocalHostName,
  portnumber := tsp_LocalHttpPort, use_ssl := false };

template Connect t_Connect := { hostname := tsp_HostName,
  portnumber := tsp_HttpPort, use_ssl := false };


template Close t_Close (template integer p_clientId) := {client_id:=p_clientId};
template Half_close t_Half_close(template integer p_clientId):={client_id:=p_clientId};


template HeaderLines t_RequestHeader(charstring par_body):=

{     		    
  { header_name := "Host", header_value := tsp_HostName&":"&int2str(tsp_HttpPort) },
  { header_name := "Accept", header_value := "text/*, text/html"  },
  { header_name := "Accept-Encoding", header_value := ""  },
  { header_name := "Content-Length", header_value := ContentLength(par_body) }
  
  }



template HeaderLines t_ResponseHeader:=

{ 
  { header_name := "Server", header_value := "My very own Web Server" },
  { header_name := "Content-Length", header_value := ? }};

template HeaderLines t_Response2Header(charstring par_body):=

{ 
  { header_name := "Server", header_value := "My very own Web Server" },
  { header_name := "Content-Length", header_value := ContentLength(par_body) }};




template HTTPMessage t_HTTP_Request
(
  integer par_client,
  template HeaderLines par_header ,
  template charstring par_body 
)

:=
{
  request:= {
    client_id:=par_client,
    method:="GET",
    uri:="/",
    version_major:=1,
    version_minor:=1,
    header:=par_header ,
    body:=par_body 
  } 
}


template HTTPMessage t_HTTP_OK_Response := {
  response := {
    client_id := ?,
    version_major := 1,
    version_minor := 1,
    statuscode := 200,
    statustext := "OK",
    header := ?,
    body := ?  //body should not be missing
  }
}



template HTTPMessage t_HTTP_NotOK_Response := {
  response := {
    client_id := ?,
    version_major := 1,
    version_minor := 1,
    statuscode := 500,
    statustext := "NOK",
    header := ?,
    body := ?  //body should not be missing
  }
}


template HTTPMessage t_HTTP_OK_Resp
(integer par_client,
  template HeaderLines par_header ,
  template charstring par_body ) := {
  response := {
    client_id := par_client,
    version_major := 1,
    version_minor := 1,
    statuscode := 200,
    statustext := "OK",
    header := par_header,
    body :=par_body  
  }
}



template HTTPMessage t_HTTP_NotOK_Resp
(integer par_client,
  template HeaderLines par_header ,
  template charstring par_body ) := {
  response := {
    client_id := par_client,
    version_major := 1,
    version_minor := 1,
    statuscode := 500,
    statustext := "NOK",
    header := par_header,
    body := par_body
  }
}


//------------------------------------------------------------------------------
function ContentLength (in charstring par_body)  return charstring
//------------------------------------------------------------------------------

{
  var charstring a:=int2str(lengthof (par_body))
  return a;

}



//----------------------------------


template  HTTPMessage t_request(in integer p_clientid):={ request := { client_id :=p_clientid, method := "GET", uri := "/json.gp?ip=89.147.71.240", version_major := 1, version_minor := 1, header := { { header_name := "Host", header_value := tsp_HostName },  { header_name := "User-Agent", header_value := "EclipseTitan/5.3" },{ header_name := "Accept", header_value := "*/*" } }, body := "" } } 


template Close t_close(integer p_clientid):= { client_id := p_clientid} 



//******************************************************
testcase tc_encdec_JSON() runs on HTTP_CT
//******************************************************

{  
  log("JSON Template before encoding : ",  t_jsonTemplate);

  var octetstring v_encodedPDU := enc_JSON(valueof(t_jsonTemplate));
  var JSON_PDU    v_decodedPDU := dec_JSON(v_encodedPDU);
  log("Encoded JSON: ", v_encodedPDU);
  log("Decoded JSON: ", v_decodedPDU);


}




//******************************************************
testcase tc_geoplugin() runs on HTTP_CT{
  //******************************************************




  //---------------------HTTP---------------------------
  var Connect_result v_Connect_result
  var Connect v_Connect  
  var Listen_result v_Listen_result
  var Listen v_Listen
  var Close v_Close
  var Half_close v_Half_close
  var Shutdown v_Shutdown
  var Client_connected v_Client_connected
  var charstring vl_char_body
  var octetstring v_body
  var HTTPMessage  v_HTTPMessage
  var integer v_http_client_id
  timer t0:=3.0;


  map(self:HTTP_PCO, system:HTTP_PCO);

  var Connect vl_connect:={ hostname := tsp_HostName, portnumber := tsp_HttpPort, use_ssl := false } 
  log("PRE-CONNECT");
  HTTP_PCO.send(vl_connect) ;
  t0.start;
  alt 
  {
	
    []HTTP_PCO.receive(Connect_result:?) -> value v_Connect_result 
    {
      v_http_client_id:=v_Connect_result.client_id;
      log("AFTER-CONNECT with ID" & int2str(v_http_client_id));
    }
    []t0.timeout 
    { 
	  log("AFTER-CONNECT: TIMEOUT")
    }
  }


  HTTP_PCO.send(t_request(v_http_client_id))
  log("Test");
  alt 
  {
	
    []HTTP_PCO.receive(HTTPMessage:?)  -> value v_HTTPMessage
    {
	log("Test");
      if (ischosen(v_HTTPMessage.response_binary))
      {
        v_body:=v_HTTPMessage.response_binary.body;
        log("v_body",v_body);
        log("encodingtype",get_stringencoding(v_body ));

      } else  if (ischosen(v_HTTPMessage.response))

      {

        vl_char_body:=v_HTTPMessage.response.body
        log("vl_char_body",vl_char_body);
        var JSON_PDU v_JSON_PDU := dec_JSON (char2oct(vl_char_body))
    log("decoded JSON response",v_JSON_PDU);        
        

      }
    }
  }

  HTTP_PCO.send(t_close(v_http_client_id)) 
  t0.start;
  alt 
  {

    []HTTP_PCO.receive {}
    []t0.timeout {}
  }


  all component.kill;
}//end tc


control
{
  execute(tc_encdec_JSON());
  execute( tc_geoplugin());
}
}  // end of module
