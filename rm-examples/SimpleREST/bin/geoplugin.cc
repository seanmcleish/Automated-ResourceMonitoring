// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R4C
// for U-LAYTEC\mcleish (mcleish@LT-411-0143) on Mon Jan  7 14:21:57 2019

// Copyright (c) 2000-2018 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "geoplugin.hh"

namespace geoplugin {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x03, 0x34, 0xb6, 0x05, 0x6f, 0x99, 0x2f, 0x52, 0x60, 0xfa, 0xcd, 0xb8, 0xd2, 0xff, 0x2f, 0x05 };

/* Global variable definitions */

// No XER for JSON__PDU
const TTCN_JSONdescriptor_t JSON__PDU_json_ = { FALSE, NULL, TRUE, NULL, FALSE, FALSE, FALSE, 0, NULL };
const TTCN_Typedescriptor_t JSON__PDU_descr_ = { "@geoplugin.JSON_PDU", NULL, NULL, NULL, NULL, &JSON__PDU_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Geoplugin__response_geoplugin__request_xer_ = { {"geoplugin_request>\n", "geoplugin_request>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__request_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_request", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__request_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__request_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__status_xer_ = { {"geoplugin_status>\n", "geoplugin_status>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__status_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_status", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Geoplugin__response_geoplugin__status_xer_, &INTEGER_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__status_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__credit_xer_ = { {"geoplugin_credit>\n", "geoplugin_credit>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__credit_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_credit", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__credit_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__credit_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__city_xer_ = { {"geoplugin_city>\n", "geoplugin_city>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__city_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_city", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__city_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__city_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__region_xer_ = { {"geoplugin_region>\n", "geoplugin_region>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__region_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_region", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__region_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__region_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__areaCode_xer_ = { {"geoplugin_areaCode>\n", "geoplugin_areaCode>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__areaCode_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_areaCode", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__areaCode_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__areaCode_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__dmaCode_xer_ = { {"geoplugin_dmaCode>\n", "geoplugin_dmaCode>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__dmaCode_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_dmaCode", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__dmaCode_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__dmaCode_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__countryCode_xer_ = { {"geoplugin_countryCode>\n", "geoplugin_countryCode>\n"}, {23, 23}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__countryCode_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_countryCode", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__countryCode_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__countryCode_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__countryName_xer_ = { {"geoplugin_countryName>\n", "geoplugin_countryName>\n"}, {23, 23}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__countryName_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_countryName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__countryName_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__countryName_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__continentCode_xer_ = { {"geoplugin_continentCode>\n", "geoplugin_continentCode>\n"}, {25, 25}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__continentCode_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_continentCode", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__continentCode_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__continentCode_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__latitude_xer_ = { {"geoplugin_latitude>\n", "geoplugin_latitude>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__latitude_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_latitude", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__latitude_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__latitude_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__longitude_xer_ = { {"geoplugin_longitude>\n", "geoplugin_longitude>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__longitude_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_longitude", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__longitude_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__longitude_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__regionCode_xer_ = { {"geoplugin_regionCode>\n", "geoplugin_regionCode>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__regionCode_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_regionCode", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__regionCode_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__regionCode_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__regionName_xer_ = { {"geoplugin_regionName>\n", "geoplugin_regionName>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__regionName_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_regionName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__regionName_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__regionName_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__currencyCode_xer_ = { {"geoplugin_currencyCode>\n", "geoplugin_currencyCode>\n"}, {24, 24}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__currencyCode_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_currencyCode", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__currencyCode_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__currencyCode_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__currencySymbol_xer_ = { {"geoplugin_currencySymbol>\n", "geoplugin_currencySymbol>\n"}, {26, 26}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__currencySymbol_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_currencySymbol", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__currencySymbol_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__currencySymbol_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__currencySymbol__UTF8_xer_ = { {"geoplugin_currencySymbol_UTF8>\n", "geoplugin_currencySymbol_UTF8>\n"}, {31, 31}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__currencySymbol__UTF8_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_currencySymbol_UTF8", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Geoplugin__response_geoplugin__currencySymbol__UTF8_xer_, &CHARSTRING_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__currencySymbol__UTF8_default_coding("JSON");
const XERdescriptor_t       Geoplugin__response_geoplugin__currencyConverter_xer_ = { {"geoplugin_currencyConverter>\n", "geoplugin_currencyConverter>\n"}, {29, 29}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int Geoplugin__response_geoplugin__currencyConverter_oer_ext_arr_[0] = {};
const int Geoplugin__response_geoplugin__currencyConverter_oer_p_[0] = {};
const TTCN_OERdescriptor_t Geoplugin__response_geoplugin__currencyConverter_oer_ = { -1, TRUE, -1, FALSE, 0, 0, Geoplugin__response_geoplugin__currencyConverter_oer_ext_arr_, 0, Geoplugin__response_geoplugin__currencyConverter_oer_p_};
const TTCN_Typedescriptor_t Geoplugin__response_geoplugin__currencyConverter_descr_ = { "@geoplugin.Geoplugin_response.geoplugin_currencyConverter", &FLOAT_ber_, &FLOAT_raw_, NULL, &Geoplugin__response_geoplugin__currencyConverter_xer_, &FLOAT_json_, &Geoplugin__response_geoplugin__currencyConverter_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_geoplugin__currencyConverter_default_coding("JSON");
// No XER for Geoplugin__response
const TTCN_JSONdescriptor_t Geoplugin__response_json_ = { FALSE, NULL, FALSE, NULL, FALSE, FALSE, FALSE, 0, NULL };
const TTCN_Typedescriptor_t Geoplugin__response_descr_ = { "@geoplugin.Geoplugin_response", NULL, NULL, NULL, NULL, &Geoplugin__response_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Geoplugin__response_default_coding("JSON");
// No XER for JSON__PDU_geoplugin__response
const TTCN_Typedescriptor_t JSON__PDU_geoplugin__response_descr_ = { "@geoplugin.JSON_PDU.geoplugin_response", NULL, NULL, NULL, NULL, &Geoplugin__response_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING JSON__PDU_geoplugin__response_default_coding("JSON");
const XERdescriptor_t       Memory__response_memoryValueAvailable_xer_ = { {"memoryValueAvailable>\n", "memoryValueAvailable>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Memory__response_memoryValueAvailable_descr_ = { "@geoplugin.Memory_response.memoryValueAvailable", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Memory__response_memoryValueAvailable_xer_, &INTEGER_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Memory__response_memoryValueAvailable_default_coding("JSON");
const XERdescriptor_t       Memory__response_memoryValueSwapTotal_xer_ = { {"memoryValueSwapTotal>\n", "memoryValueSwapTotal>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Memory__response_memoryValueSwapTotal_descr_ = { "@geoplugin.Memory_response.memoryValueSwapTotal", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Memory__response_memoryValueSwapTotal_xer_, &INTEGER_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Memory__response_memoryValueSwapTotal_default_coding("JSON");
const XERdescriptor_t       Memory__response_memoryValueSwapUsed_xer_ = { {"memoryValueSwapUsed>\n", "memoryValueSwapUsed>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Memory__response_memoryValueSwapUsed_descr_ = { "@geoplugin.Memory_response.memoryValueSwapUsed", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Memory__response_memoryValueSwapUsed_xer_, &INTEGER_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Memory__response_memoryValueSwapUsed_default_coding("JSON");
// No XER for Memory__response
const TTCN_JSONdescriptor_t Memory__response_json_ = { FALSE, NULL, FALSE, NULL, FALSE, FALSE, FALSE, 0, NULL };
const TTCN_Typedescriptor_t Memory__response_descr_ = { "@geoplugin.Memory_response", NULL, NULL, NULL, NULL, &Memory__response_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING Memory__response_default_coding("JSON");
// No XER for JSON__PDU_memory__response
const TTCN_Typedescriptor_t JSON__PDU_memory__response_descr_ = { "@geoplugin.JSON_PDU.memory_response", NULL, NULL, NULL, NULL, &Memory__response_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING JSON__PDU_memory__response_default_coding("JSON");
UNIVERSAL_CHARSTRING JSON__PDU_default_coding("JSON");
TTCN_Module module_object("geoplugin", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_2,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

void JSON__PDU::copy_value(const JSON__PDU& other_value)
{
switch (other_value.union_selection) {
case ALT_geoplugin__response:
field_geoplugin__response = new Geoplugin__response(*other_value.field_geoplugin__response);
break;
case ALT_memory__response:
field_memory__response = new Memory__response(*other_value.field_memory__response);
break;
default:
TTCN_error("Assignment of an unbound union value of type @geoplugin.JSON_PDU.");
}
union_selection = other_value.union_selection;
}

JSON__PDU::JSON__PDU()
{
union_selection = UNBOUND_VALUE;
}

JSON__PDU::JSON__PDU(const JSON__PDU& other_value)
: Base_Type(){
copy_value(other_value);
}

JSON__PDU::~JSON__PDU()
{
clean_up();
}

JSON__PDU& JSON__PDU::operator=(const JSON__PDU& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean JSON__PDU::operator==(const JSON__PDU& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @geoplugin.JSON_PDU.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @geoplugin.JSON_PDU.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_geoplugin__response:
return *field_geoplugin__response == *other_value.field_geoplugin__response;
case ALT_memory__response:
return *field_memory__response == *other_value.field_memory__response;
default:
return FALSE;
}
}

Geoplugin__response& JSON__PDU::geoplugin__response()
{
if (union_selection != ALT_geoplugin__response) {
clean_up();
field_geoplugin__response = new Geoplugin__response;
union_selection = ALT_geoplugin__response;
}
return *field_geoplugin__response;
}

const Geoplugin__response& JSON__PDU::geoplugin__response() const
{
if (union_selection != ALT_geoplugin__response) TTCN_error("Using non-selected field geoplugin_response in a value of union type @geoplugin.JSON_PDU.");
return *field_geoplugin__response;
}

Memory__response& JSON__PDU::memory__response()
{
if (union_selection != ALT_memory__response) {
clean_up();
field_memory__response = new Memory__response;
union_selection = ALT_memory__response;
}
return *field_memory__response;
}

const Memory__response& JSON__PDU::memory__response() const
{
if (union_selection != ALT_memory__response) TTCN_error("Using non-selected field memory_response in a value of union type @geoplugin.JSON_PDU.");
return *field_memory__response;
}

boolean JSON__PDU::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @geoplugin.JSON_PDU.");
return union_selection == checked_selection;
}

boolean JSON__PDU::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean JSON__PDU::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_geoplugin__response: return field_geoplugin__response->is_value();
case ALT_memory__response: return field_memory__response->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void JSON__PDU::clean_up()
{
switch (union_selection) {
case ALT_geoplugin__response:
  delete field_geoplugin__response;
  break;
case ALT_memory__response:
  delete field_memory__response;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void JSON__PDU::log() const
{
switch (union_selection) {
case ALT_geoplugin__response:
TTCN_Logger::log_event_str("{ geoplugin_response := ");
field_geoplugin__response->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_memory__response:
TTCN_Logger::log_event_str("{ memory_response := ");
field_memory__response->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void JSON__PDU::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  char* last_name = mp_last->get_id()->get_name();
  if (!strcmp(last_name, "geoplugin_response")) {
    geoplugin__response().set_param(*mp_last);
    if (!geoplugin__response().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "memory_response")) {
    memory__response().set_param(*mp_last);
    if (!memory__response().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @geoplugin.JSON_PDU.", last_name);
}

void JSON__PDU::set_implicit_omit()
{
switch (union_selection) {
case ALT_geoplugin__response:
field_geoplugin__response->set_implicit_omit(); break;
case ALT_memory__response:
field_memory__response->set_implicit_omit(); break;
default: break;
}
}

void JSON__PDU::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_geoplugin__response:
field_geoplugin__response->encode_text(text_buf);
break;
case ALT_memory__response:
field_memory__response->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @geoplugin.JSON_PDU.");
}
}

void JSON__PDU::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_geoplugin__response:
geoplugin__response().decode_text(text_buf);
break;
case ALT_memory__response:
memory__response().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @geoplugin.JSON_PDU.");
}
}

void JSON__PDU::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void JSON__PDU::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int JSON__PDU::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = 0;
  switch(union_selection) {
  case ALT_geoplugin__response:
    enc_len += field_geoplugin__response->JSON_encode(JSON__PDU_geoplugin__response_descr_, p_tok);
    break;
  case ALT_memory__response:
    enc_len += field_memory__response->JSON_encode(JSON__PDU_memory__response_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @geoplugin.JSON_PDU.");
    return -1;
  }

  return enc_len;
}

int JSON__PDU::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent, int p_chosen_field)
{
  if (0 <= p_chosen_field && 2 > p_chosen_field) {
    switch (p_chosen_field) {
    case 0:
      return geoplugin__response().JSON_decode(JSON__PDU_geoplugin__response_descr_, p_tok, TRUE);
    case 1:
      return memory__response().JSON_decode(JSON__PDU_memory__response_descr_, p_tok, TRUE);
    }
  }
  json_token_t j_token = JSON_TOKEN_NONE;
  size_t buf_pos = p_tok.get_buf_pos();
  p_tok.get_next_token(&j_token, NULL, NULL);
  int ret_val = 0;
  switch(j_token) {
  case JSON_TOKEN_NUMBER: {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_AS_VALUE_ERROR, "number");
    clean_up();
    return JSON_ERROR_FATAL;
  }
  case JSON_TOKEN_STRING: {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_AS_VALUE_ERROR, "string");
    clean_up();
    return JSON_ERROR_FATAL;
  }
  case JSON_TOKEN_LITERAL_TRUE:
  case JSON_TOKEN_LITERAL_FALSE: {
    char* literal_str = mprintf("literal (%s)",
      (JSON_TOKEN_LITERAL_TRUE == j_token) ? "true" : "false");
    try {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_AS_VALUE_ERROR, literal_str);
    }
    catch (const TC_Error&) {
      Free(literal_str);
      throw;
    }
    Free(literal_str);
    clean_up();
    return JSON_ERROR_FATAL;
  }
  case JSON_TOKEN_ARRAY_START: {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_AS_VALUE_ERROR, "array");
    clean_up();
    return JSON_ERROR_FATAL;
  }
  case JSON_TOKEN_OBJECT_START: {
    p_tok.set_buf_pos(buf_pos);
    ret_val = geoplugin__response().JSON_decode(JSON__PDU_geoplugin__response_descr_, p_tok, TRUE);
    if (0 <= ret_val) {
      return ret_val;
    }
    p_tok.set_buf_pos(buf_pos);
    ret_val = memory__response().JSON_decode(JSON__PDU_memory__response_descr_, p_tok, TRUE);
    if (0 <= ret_val) {
      return ret_val;
    }
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_AS_VALUE_ERROR, "object");
    clean_up();
    return JSON_ERROR_FATAL;
  }
  case JSON_TOKEN_LITERAL_NULL: {
    clean_up();
    return JSON_ERROR_INVALID_TOKEN;
  }
  case JSON_TOKEN_ERROR:
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  default:
    return JSON_ERROR_INVALID_TOKEN;
  }
  return ret_val;
}

void JSON__PDU_template::copy_value(const JSON__PDU& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
single_value.field_geoplugin__response = new Geoplugin__response_template(other_value.geoplugin__response());
break;
case JSON__PDU::ALT_memory__response:
single_value.field_memory__response = new Memory__response_template(other_value.memory__response());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @geoplugin.JSON_PDU.");
}
set_selection(SPECIFIC_VALUE);
}

void JSON__PDU_template::copy_template(const JSON__PDU_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
single_value.field_geoplugin__response = new Geoplugin__response_template(*other_value.single_value.field_geoplugin__response);
break;
case JSON__PDU::ALT_memory__response:
single_value.field_memory__response = new Memory__response_template(*other_value.single_value.field_memory__response);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @geoplugin.JSON_PDU.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new JSON__PDU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @geoplugin.JSON_PDU.");
}
set_selection(other_value);
}

JSON__PDU_template::JSON__PDU_template()
{
}

JSON__PDU_template::JSON__PDU_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

JSON__PDU_template::JSON__PDU_template(const JSON__PDU& other_value)
{
copy_value(other_value);
}

JSON__PDU_template::JSON__PDU_template(const OPTIONAL<JSON__PDU>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const JSON__PDU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @geoplugin.JSON_PDU from an unbound optional field.");
}
}

JSON__PDU_template::JSON__PDU_template(const JSON__PDU_template& other_value)
: Base_Template(){
copy_template(other_value);
}

JSON__PDU_template::~JSON__PDU_template()
{
clean_up();
}

void JSON__PDU_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
delete single_value.field_geoplugin__response;
break;
case JSON__PDU::ALT_memory__response:
delete single_value.field_memory__response;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

JSON__PDU_template& JSON__PDU_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

JSON__PDU_template& JSON__PDU_template::operator=(const JSON__PDU& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

JSON__PDU_template& JSON__PDU_template::operator=(const OPTIONAL<JSON__PDU>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const JSON__PDU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @geoplugin.JSON_PDU.");
}
return *this;
}

JSON__PDU_template& JSON__PDU_template::operator=(const JSON__PDU_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean JSON__PDU_template::match(const JSON__PDU& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
JSON__PDU::union_selection_type value_selection = other_value.get_selection();
if (value_selection == JSON__PDU::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case JSON__PDU::ALT_geoplugin__response:
return single_value.field_geoplugin__response->match(other_value.geoplugin__response(), legacy);
case JSON__PDU::ALT_memory__response:
return single_value.field_memory__response->match(other_value.memory__response(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @geoplugin.JSON_PDU.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @geoplugin.JSON_PDU.");
}
return FALSE;
}

boolean JSON__PDU_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
return single_value.field_geoplugin__response->is_value();
case JSON__PDU::ALT_memory__response:
return single_value.field_memory__response->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @geoplugin.JSON_PDU.");
}
}

JSON__PDU JSON__PDU_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @geoplugin.JSON_PDU.");
JSON__PDU ret_val;
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
ret_val.geoplugin__response() = single_value.field_geoplugin__response->valueof();
break;
case JSON__PDU::ALT_memory__response:
ret_val.memory__response() = single_value.field_memory__response->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @geoplugin.JSON_PDU.");
}
return ret_val;
}

JSON__PDU_template& JSON__PDU_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @geoplugin.JSON_PDU.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @geoplugin.JSON_PDU.");
return value_list.list_value[list_index];
}
void JSON__PDU_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @geoplugin.JSON_PDU.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new JSON__PDU_template[list_length];
}

Geoplugin__response_template& JSON__PDU_template::geoplugin__response()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != JSON__PDU::ALT_geoplugin__response) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoplugin__response = new Geoplugin__response_template(ANY_VALUE);
else single_value.field_geoplugin__response = new Geoplugin__response_template;
single_value.union_selection = JSON__PDU::ALT_geoplugin__response;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoplugin__response;
}

const Geoplugin__response_template& JSON__PDU_template::geoplugin__response() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoplugin_response in a non-specific template of union type @geoplugin.JSON_PDU.");
if (single_value.union_selection != JSON__PDU::ALT_geoplugin__response) TTCN_error("Accessing non-selected field geoplugin_response in a template of union type @geoplugin.JSON_PDU.");
return *single_value.field_geoplugin__response;
}

Memory__response_template& JSON__PDU_template::memory__response()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != JSON__PDU::ALT_memory__response) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_memory__response = new Memory__response_template(ANY_VALUE);
else single_value.field_memory__response = new Memory__response_template;
single_value.union_selection = JSON__PDU::ALT_memory__response;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_memory__response;
}

const Memory__response_template& JSON__PDU_template::memory__response() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field memory_response in a non-specific template of union type @geoplugin.JSON_PDU.");
if (single_value.union_selection != JSON__PDU::ALT_memory__response) TTCN_error("Accessing non-selected field memory_response in a template of union type @geoplugin.JSON_PDU.");
return *single_value.field_memory__response;
}

boolean JSON__PDU_template::ischosen(JSON__PDU::union_selection_type checked_selection) const
{
if (checked_selection == JSON__PDU::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @geoplugin.JSON_PDU.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == JSON__PDU::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @geoplugin.JSON_PDU.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @geoplugin.JSON_PDU containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
for (unsigned int list_count = 1; ret_val == TRUE && list_count < value_list.n_values; list_count++) {
ret_val = value_list.list_value[list_count].ischosen(checked_selection);
}
return ret_val;
}
default:
return FALSE;
}
return FALSE;
}

void JSON__PDU_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
TTCN_Logger::log_event_str("{ geoplugin_response := ");
single_value.field_geoplugin__response->log();
TTCN_Logger::log_event_str(" }");
break;
case JSON__PDU::ALT_memory__response:
TTCN_Logger::log_event_str("{ memory_response := ");
single_value.field_memory__response->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void JSON__PDU_template::log_match(const JSON__PDU& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoplugin_response");
single_value.field_geoplugin__response->log_match(match_value.geoplugin__response(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoplugin_response := ");
single_value.field_geoplugin__response->log_match(match_value.geoplugin__response(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case JSON__PDU::ALT_memory__response:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".memory_response");
single_value.field_memory__response->log_match(match_value.memory__response(), legacy);
} else {
TTCN_Logger::log_event_str("{ memory_response := ");
single_value.field_memory__response->log_match(match_value.memory__response(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void JSON__PDU_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
single_value.field_geoplugin__response->encode_text(text_buf);
break;
case JSON__PDU::ALT_memory__response:
single_value.field_memory__response->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @geoplugin.JSON_PDU.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @geoplugin.JSON_PDU.");
}
}

void JSON__PDU_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = JSON__PDU::UNBOUND_VALUE;
JSON__PDU::union_selection_type new_selection = (JSON__PDU::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case JSON__PDU::ALT_geoplugin__response:
single_value.field_geoplugin__response = new Geoplugin__response_template;
single_value.field_geoplugin__response->decode_text(text_buf);
break;
case JSON__PDU::ALT_memory__response:
single_value.field_memory__response = new Memory__response_template;
single_value.field_memory__response->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @geoplugin.JSON_PDU.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new JSON__PDU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @geoplugin.JSON_PDU.");
}
}

boolean JSON__PDU_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean JSON__PDU_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void JSON__PDU_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@geoplugin.JSON_PDU'");
    }
    if (strcmp("geoplugin_response", param_field) == 0) {
      geoplugin__response().set_param(param);
      return;
    } else if (strcmp("memory_response", param_field) == 0) {
      memory__response().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@geoplugin.JSON_PDU'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    JSON__PDU_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@geoplugin.JSON_PDU");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    char* last_name = mp_last->get_id()->get_name();
    if (!strcmp(last_name, "geoplugin_response")) {
      geoplugin__response().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "memory_response")) {
      memory__response().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @geoplugin.JSON_PDU.", last_name);
  } break;
  default:
    param.type_error("union template", "@geoplugin.JSON_PDU");
  }
  is_ifpresent = param.get_ifpresent();
}

void JSON__PDU_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case JSON__PDU::ALT_geoplugin__response:
single_value.field_geoplugin__response->check_restriction(t_res, t_name ? t_name : "@geoplugin.JSON_PDU");
return;
case JSON__PDU::ALT_memory__response:
single_value.field_memory__response->check_restriction(t_res, t_name ? t_name : "@geoplugin.JSON_PDU");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @geoplugin.JSON_PDU.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@geoplugin.JSON_PDU");
}

Geoplugin__response::Geoplugin__response()
{
}

Geoplugin__response::Geoplugin__response(const CHARSTRING& par_geoplugin__request,
    const INTEGER& par_geoplugin__status,
    const CHARSTRING& par_geoplugin__credit,
    const CHARSTRING& par_geoplugin__city,
    const CHARSTRING& par_geoplugin__region,
    const CHARSTRING& par_geoplugin__areaCode,
    const CHARSTRING& par_geoplugin__dmaCode,
    const CHARSTRING& par_geoplugin__countryCode,
    const CHARSTRING& par_geoplugin__countryName,
    const CHARSTRING& par_geoplugin__continentCode,
    const CHARSTRING& par_geoplugin__latitude,
    const CHARSTRING& par_geoplugin__longitude,
    const CHARSTRING& par_geoplugin__regionCode,
    const CHARSTRING& par_geoplugin__regionName,
    const CHARSTRING& par_geoplugin__currencyCode,
    const CHARSTRING& par_geoplugin__currencySymbol,
    const CHARSTRING& par_geoplugin__currencySymbol__UTF8,
    const FLOAT& par_geoplugin__currencyConverter)
  :   field_geoplugin__request(par_geoplugin__request),
  field_geoplugin__status(par_geoplugin__status),
  field_geoplugin__credit(par_geoplugin__credit),
  field_geoplugin__city(par_geoplugin__city),
  field_geoplugin__region(par_geoplugin__region),
  field_geoplugin__areaCode(par_geoplugin__areaCode),
  field_geoplugin__dmaCode(par_geoplugin__dmaCode),
  field_geoplugin__countryCode(par_geoplugin__countryCode),
  field_geoplugin__countryName(par_geoplugin__countryName),
  field_geoplugin__continentCode(par_geoplugin__continentCode),
  field_geoplugin__latitude(par_geoplugin__latitude),
  field_geoplugin__longitude(par_geoplugin__longitude),
  field_geoplugin__regionCode(par_geoplugin__regionCode),
  field_geoplugin__regionName(par_geoplugin__regionName),
  field_geoplugin__currencyCode(par_geoplugin__currencyCode),
  field_geoplugin__currencySymbol(par_geoplugin__currencySymbol),
  field_geoplugin__currencySymbol__UTF8(par_geoplugin__currencySymbol__UTF8),
  field_geoplugin__currencyConverter(par_geoplugin__currencyConverter)
{
}

Geoplugin__response::Geoplugin__response(const Geoplugin__response& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @geoplugin.Geoplugin_response.");
if (other_value.geoplugin__request().is_bound()) field_geoplugin__request = other_value.geoplugin__request();
else field_geoplugin__request.clean_up();
if (other_value.geoplugin__status().is_bound()) field_geoplugin__status = other_value.geoplugin__status();
else field_geoplugin__status.clean_up();
if (other_value.geoplugin__credit().is_bound()) field_geoplugin__credit = other_value.geoplugin__credit();
else field_geoplugin__credit.clean_up();
if (other_value.geoplugin__city().is_bound()) field_geoplugin__city = other_value.geoplugin__city();
else field_geoplugin__city.clean_up();
if (other_value.geoplugin__region().is_bound()) field_geoplugin__region = other_value.geoplugin__region();
else field_geoplugin__region.clean_up();
if (other_value.geoplugin__areaCode().is_bound()) field_geoplugin__areaCode = other_value.geoplugin__areaCode();
else field_geoplugin__areaCode.clean_up();
if (other_value.geoplugin__dmaCode().is_bound()) field_geoplugin__dmaCode = other_value.geoplugin__dmaCode();
else field_geoplugin__dmaCode.clean_up();
if (other_value.geoplugin__countryCode().is_bound()) field_geoplugin__countryCode = other_value.geoplugin__countryCode();
else field_geoplugin__countryCode.clean_up();
if (other_value.geoplugin__countryName().is_bound()) field_geoplugin__countryName = other_value.geoplugin__countryName();
else field_geoplugin__countryName.clean_up();
if (other_value.geoplugin__continentCode().is_bound()) field_geoplugin__continentCode = other_value.geoplugin__continentCode();
else field_geoplugin__continentCode.clean_up();
if (other_value.geoplugin__latitude().is_bound()) field_geoplugin__latitude = other_value.geoplugin__latitude();
else field_geoplugin__latitude.clean_up();
if (other_value.geoplugin__longitude().is_bound()) field_geoplugin__longitude = other_value.geoplugin__longitude();
else field_geoplugin__longitude.clean_up();
if (other_value.geoplugin__regionCode().is_bound()) field_geoplugin__regionCode = other_value.geoplugin__regionCode();
else field_geoplugin__regionCode.clean_up();
if (other_value.geoplugin__regionName().is_bound()) field_geoplugin__regionName = other_value.geoplugin__regionName();
else field_geoplugin__regionName.clean_up();
if (other_value.geoplugin__currencyCode().is_bound()) field_geoplugin__currencyCode = other_value.geoplugin__currencyCode();
else field_geoplugin__currencyCode.clean_up();
if (other_value.geoplugin__currencySymbol().is_bound()) field_geoplugin__currencySymbol = other_value.geoplugin__currencySymbol();
else field_geoplugin__currencySymbol.clean_up();
if (other_value.geoplugin__currencySymbol__UTF8().is_bound()) field_geoplugin__currencySymbol__UTF8 = other_value.geoplugin__currencySymbol__UTF8();
else field_geoplugin__currencySymbol__UTF8.clean_up();
if (other_value.geoplugin__currencyConverter().is_bound()) field_geoplugin__currencyConverter = other_value.geoplugin__currencyConverter();
else field_geoplugin__currencyConverter.clean_up();
}

void Geoplugin__response::clean_up()
{
field_geoplugin__request.clean_up();
field_geoplugin__status.clean_up();
field_geoplugin__credit.clean_up();
field_geoplugin__city.clean_up();
field_geoplugin__region.clean_up();
field_geoplugin__areaCode.clean_up();
field_geoplugin__dmaCode.clean_up();
field_geoplugin__countryCode.clean_up();
field_geoplugin__countryName.clean_up();
field_geoplugin__continentCode.clean_up();
field_geoplugin__latitude.clean_up();
field_geoplugin__longitude.clean_up();
field_geoplugin__regionCode.clean_up();
field_geoplugin__regionName.clean_up();
field_geoplugin__currencyCode.clean_up();
field_geoplugin__currencySymbol.clean_up();
field_geoplugin__currencySymbol__UTF8.clean_up();
field_geoplugin__currencyConverter.clean_up();
}

const TTCN_Typedescriptor_t* Geoplugin__response::get_descriptor() const { return &Geoplugin__response_descr_; }
Geoplugin__response& Geoplugin__response::operator=(const Geoplugin__response& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @geoplugin.Geoplugin_response.");
  if (other_value.geoplugin__request().is_bound()) field_geoplugin__request = other_value.geoplugin__request();
  else field_geoplugin__request.clean_up();
  if (other_value.geoplugin__status().is_bound()) field_geoplugin__status = other_value.geoplugin__status();
  else field_geoplugin__status.clean_up();
  if (other_value.geoplugin__credit().is_bound()) field_geoplugin__credit = other_value.geoplugin__credit();
  else field_geoplugin__credit.clean_up();
  if (other_value.geoplugin__city().is_bound()) field_geoplugin__city = other_value.geoplugin__city();
  else field_geoplugin__city.clean_up();
  if (other_value.geoplugin__region().is_bound()) field_geoplugin__region = other_value.geoplugin__region();
  else field_geoplugin__region.clean_up();
  if (other_value.geoplugin__areaCode().is_bound()) field_geoplugin__areaCode = other_value.geoplugin__areaCode();
  else field_geoplugin__areaCode.clean_up();
  if (other_value.geoplugin__dmaCode().is_bound()) field_geoplugin__dmaCode = other_value.geoplugin__dmaCode();
  else field_geoplugin__dmaCode.clean_up();
  if (other_value.geoplugin__countryCode().is_bound()) field_geoplugin__countryCode = other_value.geoplugin__countryCode();
  else field_geoplugin__countryCode.clean_up();
  if (other_value.geoplugin__countryName().is_bound()) field_geoplugin__countryName = other_value.geoplugin__countryName();
  else field_geoplugin__countryName.clean_up();
  if (other_value.geoplugin__continentCode().is_bound()) field_geoplugin__continentCode = other_value.geoplugin__continentCode();
  else field_geoplugin__continentCode.clean_up();
  if (other_value.geoplugin__latitude().is_bound()) field_geoplugin__latitude = other_value.geoplugin__latitude();
  else field_geoplugin__latitude.clean_up();
  if (other_value.geoplugin__longitude().is_bound()) field_geoplugin__longitude = other_value.geoplugin__longitude();
  else field_geoplugin__longitude.clean_up();
  if (other_value.geoplugin__regionCode().is_bound()) field_geoplugin__regionCode = other_value.geoplugin__regionCode();
  else field_geoplugin__regionCode.clean_up();
  if (other_value.geoplugin__regionName().is_bound()) field_geoplugin__regionName = other_value.geoplugin__regionName();
  else field_geoplugin__regionName.clean_up();
  if (other_value.geoplugin__currencyCode().is_bound()) field_geoplugin__currencyCode = other_value.geoplugin__currencyCode();
  else field_geoplugin__currencyCode.clean_up();
  if (other_value.geoplugin__currencySymbol().is_bound()) field_geoplugin__currencySymbol = other_value.geoplugin__currencySymbol();
  else field_geoplugin__currencySymbol.clean_up();
  if (other_value.geoplugin__currencySymbol__UTF8().is_bound()) field_geoplugin__currencySymbol__UTF8 = other_value.geoplugin__currencySymbol__UTF8();
  else field_geoplugin__currencySymbol__UTF8.clean_up();
  if (other_value.geoplugin__currencyConverter().is_bound()) field_geoplugin__currencyConverter = other_value.geoplugin__currencyConverter();
  else field_geoplugin__currencyConverter.clean_up();
}
return *this;
}

boolean Geoplugin__response::operator==(const Geoplugin__response& other_value) const
{
return field_geoplugin__request==other_value.field_geoplugin__request
  && field_geoplugin__status==other_value.field_geoplugin__status
  && field_geoplugin__credit==other_value.field_geoplugin__credit
  && field_geoplugin__city==other_value.field_geoplugin__city
  && field_geoplugin__region==other_value.field_geoplugin__region
  && field_geoplugin__areaCode==other_value.field_geoplugin__areaCode
  && field_geoplugin__dmaCode==other_value.field_geoplugin__dmaCode
  && field_geoplugin__countryCode==other_value.field_geoplugin__countryCode
  && field_geoplugin__countryName==other_value.field_geoplugin__countryName
  && field_geoplugin__continentCode==other_value.field_geoplugin__continentCode
  && field_geoplugin__latitude==other_value.field_geoplugin__latitude
  && field_geoplugin__longitude==other_value.field_geoplugin__longitude
  && field_geoplugin__regionCode==other_value.field_geoplugin__regionCode
  && field_geoplugin__regionName==other_value.field_geoplugin__regionName
  && field_geoplugin__currencyCode==other_value.field_geoplugin__currencyCode
  && field_geoplugin__currencySymbol==other_value.field_geoplugin__currencySymbol
  && field_geoplugin__currencySymbol__UTF8==other_value.field_geoplugin__currencySymbol__UTF8
  && field_geoplugin__currencyConverter==other_value.field_geoplugin__currencyConverter;
}

boolean Geoplugin__response::is_bound() const
{
if(field_geoplugin__request.is_bound()) return TRUE;
if(field_geoplugin__status.is_bound()) return TRUE;
if(field_geoplugin__credit.is_bound()) return TRUE;
if(field_geoplugin__city.is_bound()) return TRUE;
if(field_geoplugin__region.is_bound()) return TRUE;
if(field_geoplugin__areaCode.is_bound()) return TRUE;
if(field_geoplugin__dmaCode.is_bound()) return TRUE;
if(field_geoplugin__countryCode.is_bound()) return TRUE;
if(field_geoplugin__countryName.is_bound()) return TRUE;
if(field_geoplugin__continentCode.is_bound()) return TRUE;
if(field_geoplugin__latitude.is_bound()) return TRUE;
if(field_geoplugin__longitude.is_bound()) return TRUE;
if(field_geoplugin__regionCode.is_bound()) return TRUE;
if(field_geoplugin__regionName.is_bound()) return TRUE;
if(field_geoplugin__currencyCode.is_bound()) return TRUE;
if(field_geoplugin__currencySymbol.is_bound()) return TRUE;
if(field_geoplugin__currencySymbol__UTF8.is_bound()) return TRUE;
if(field_geoplugin__currencyConverter.is_bound()) return TRUE;
return FALSE;
}
boolean Geoplugin__response::is_value() const
{
if(!field_geoplugin__request.is_value()) return FALSE;
if(!field_geoplugin__status.is_value()) return FALSE;
if(!field_geoplugin__credit.is_value()) return FALSE;
if(!field_geoplugin__city.is_value()) return FALSE;
if(!field_geoplugin__region.is_value()) return FALSE;
if(!field_geoplugin__areaCode.is_value()) return FALSE;
if(!field_geoplugin__dmaCode.is_value()) return FALSE;
if(!field_geoplugin__countryCode.is_value()) return FALSE;
if(!field_geoplugin__countryName.is_value()) return FALSE;
if(!field_geoplugin__continentCode.is_value()) return FALSE;
if(!field_geoplugin__latitude.is_value()) return FALSE;
if(!field_geoplugin__longitude.is_value()) return FALSE;
if(!field_geoplugin__regionCode.is_value()) return FALSE;
if(!field_geoplugin__regionName.is_value()) return FALSE;
if(!field_geoplugin__currencyCode.is_value()) return FALSE;
if(!field_geoplugin__currencySymbol.is_value()) return FALSE;
if(!field_geoplugin__currencySymbol__UTF8.is_value()) return FALSE;
if(!field_geoplugin__currencyConverter.is_value()) return FALSE;
return TRUE;
}
void Geoplugin__response::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ geoplugin_request := ");
field_geoplugin__request.log();
TTCN_Logger::log_event_str(", geoplugin_status := ");
field_geoplugin__status.log();
TTCN_Logger::log_event_str(", geoplugin_credit := ");
field_geoplugin__credit.log();
TTCN_Logger::log_event_str(", geoplugin_city := ");
field_geoplugin__city.log();
TTCN_Logger::log_event_str(", geoplugin_region := ");
field_geoplugin__region.log();
TTCN_Logger::log_event_str(", geoplugin_areaCode := ");
field_geoplugin__areaCode.log();
TTCN_Logger::log_event_str(", geoplugin_dmaCode := ");
field_geoplugin__dmaCode.log();
TTCN_Logger::log_event_str(", geoplugin_countryCode := ");
field_geoplugin__countryCode.log();
TTCN_Logger::log_event_str(", geoplugin_countryName := ");
field_geoplugin__countryName.log();
TTCN_Logger::log_event_str(", geoplugin_continentCode := ");
field_geoplugin__continentCode.log();
TTCN_Logger::log_event_str(", geoplugin_latitude := ");
field_geoplugin__latitude.log();
TTCN_Logger::log_event_str(", geoplugin_longitude := ");
field_geoplugin__longitude.log();
TTCN_Logger::log_event_str(", geoplugin_regionCode := ");
field_geoplugin__regionCode.log();
TTCN_Logger::log_event_str(", geoplugin_regionName := ");
field_geoplugin__regionName.log();
TTCN_Logger::log_event_str(", geoplugin_currencyCode := ");
field_geoplugin__currencyCode.log();
TTCN_Logger::log_event_str(", geoplugin_currencySymbol := ");
field_geoplugin__currencySymbol.log();
TTCN_Logger::log_event_str(", geoplugin_currencySymbol_UTF8 := ");
field_geoplugin__currencySymbol__UTF8.log();
TTCN_Logger::log_event_str(", geoplugin_currencyConverter := ");
field_geoplugin__currencyConverter.log();
TTCN_Logger::log_event_str(" }");
}

void Geoplugin__response::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (18<param.get_size()) {
      param.error("record value of type @geoplugin.Geoplugin_response has 18 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoplugin__request().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoplugin__status().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) geoplugin__credit().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) geoplugin__city().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) geoplugin__region().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) geoplugin__areaCode().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) geoplugin__dmaCode().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) geoplugin__countryCode().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) geoplugin__countryName().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) geoplugin__continentCode().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) geoplugin__latitude().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) geoplugin__longitude().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) geoplugin__regionCode().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) geoplugin__regionName().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencyCode().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencySymbol().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencySymbol__UTF8().set_param(*param.get_elem(16));
    if (param.get_size()>17 && param.get_elem(17)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencyConverter().set_param(*param.get_elem(17));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_request")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__request().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_status")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__status().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_credit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__credit().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_city")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__city().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__region().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_areaCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__areaCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_dmaCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__dmaCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_countryCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__countryCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_countryName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__countryName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_continentCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__continentCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__latitude().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__longitude().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_regionCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__regionCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_regionName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__regionName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencyCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencyCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencySymbol")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencySymbol().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencySymbol_UTF8")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencySymbol__UTF8().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencyConverter")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencyConverter().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @geoplugin.Geoplugin_response: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@geoplugin.Geoplugin_response");
  }
}

void Geoplugin__response::set_implicit_omit()
{
if (geoplugin__request().is_bound()) geoplugin__request().set_implicit_omit();
if (geoplugin__status().is_bound()) geoplugin__status().set_implicit_omit();
if (geoplugin__credit().is_bound()) geoplugin__credit().set_implicit_omit();
if (geoplugin__city().is_bound()) geoplugin__city().set_implicit_omit();
if (geoplugin__region().is_bound()) geoplugin__region().set_implicit_omit();
if (geoplugin__areaCode().is_bound()) geoplugin__areaCode().set_implicit_omit();
if (geoplugin__dmaCode().is_bound()) geoplugin__dmaCode().set_implicit_omit();
if (geoplugin__countryCode().is_bound()) geoplugin__countryCode().set_implicit_omit();
if (geoplugin__countryName().is_bound()) geoplugin__countryName().set_implicit_omit();
if (geoplugin__continentCode().is_bound()) geoplugin__continentCode().set_implicit_omit();
if (geoplugin__latitude().is_bound()) geoplugin__latitude().set_implicit_omit();
if (geoplugin__longitude().is_bound()) geoplugin__longitude().set_implicit_omit();
if (geoplugin__regionCode().is_bound()) geoplugin__regionCode().set_implicit_omit();
if (geoplugin__regionName().is_bound()) geoplugin__regionName().set_implicit_omit();
if (geoplugin__currencyCode().is_bound()) geoplugin__currencyCode().set_implicit_omit();
if (geoplugin__currencySymbol().is_bound()) geoplugin__currencySymbol().set_implicit_omit();
if (geoplugin__currencySymbol__UTF8().is_bound()) geoplugin__currencySymbol__UTF8().set_implicit_omit();
if (geoplugin__currencyConverter().is_bound()) geoplugin__currencyConverter().set_implicit_omit();
}

void Geoplugin__response::encode_text(Text_Buf& text_buf) const
{
field_geoplugin__request.encode_text(text_buf);
field_geoplugin__status.encode_text(text_buf);
field_geoplugin__credit.encode_text(text_buf);
field_geoplugin__city.encode_text(text_buf);
field_geoplugin__region.encode_text(text_buf);
field_geoplugin__areaCode.encode_text(text_buf);
field_geoplugin__dmaCode.encode_text(text_buf);
field_geoplugin__countryCode.encode_text(text_buf);
field_geoplugin__countryName.encode_text(text_buf);
field_geoplugin__continentCode.encode_text(text_buf);
field_geoplugin__latitude.encode_text(text_buf);
field_geoplugin__longitude.encode_text(text_buf);
field_geoplugin__regionCode.encode_text(text_buf);
field_geoplugin__regionName.encode_text(text_buf);
field_geoplugin__currencyCode.encode_text(text_buf);
field_geoplugin__currencySymbol.encode_text(text_buf);
field_geoplugin__currencySymbol__UTF8.encode_text(text_buf);
field_geoplugin__currencyConverter.encode_text(text_buf);
}

void Geoplugin__response::decode_text(Text_Buf& text_buf)
{
field_geoplugin__request.decode_text(text_buf);
field_geoplugin__status.decode_text(text_buf);
field_geoplugin__credit.decode_text(text_buf);
field_geoplugin__city.decode_text(text_buf);
field_geoplugin__region.decode_text(text_buf);
field_geoplugin__areaCode.decode_text(text_buf);
field_geoplugin__dmaCode.decode_text(text_buf);
field_geoplugin__countryCode.decode_text(text_buf);
field_geoplugin__countryName.decode_text(text_buf);
field_geoplugin__continentCode.decode_text(text_buf);
field_geoplugin__latitude.decode_text(text_buf);
field_geoplugin__longitude.decode_text(text_buf);
field_geoplugin__regionCode.decode_text(text_buf);
field_geoplugin__regionName.decode_text(text_buf);
field_geoplugin__currencyCode.decode_text(text_buf);
field_geoplugin__currencySymbol.decode_text(text_buf);
field_geoplugin__currencySymbol__UTF8.decode_text(text_buf);
field_geoplugin__currencyConverter.decode_text(text_buf);
}

void Geoplugin__response::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Geoplugin__response::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Geoplugin__response::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @geoplugin.Geoplugin_response.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_request");
    enc_len += field_geoplugin__request.JSON_encode(Geoplugin__response_geoplugin__request_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_status");
    enc_len += field_geoplugin__status.JSON_encode(Geoplugin__response_geoplugin__status_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_credit");
    enc_len += field_geoplugin__credit.JSON_encode(Geoplugin__response_geoplugin__credit_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_city");
    enc_len += field_geoplugin__city.JSON_encode(Geoplugin__response_geoplugin__city_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_region");
    enc_len += field_geoplugin__region.JSON_encode(Geoplugin__response_geoplugin__region_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_areaCode");
    enc_len += field_geoplugin__areaCode.JSON_encode(Geoplugin__response_geoplugin__areaCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_dmaCode");
    enc_len += field_geoplugin__dmaCode.JSON_encode(Geoplugin__response_geoplugin__dmaCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_countryCode");
    enc_len += field_geoplugin__countryCode.JSON_encode(Geoplugin__response_geoplugin__countryCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_countryName");
    enc_len += field_geoplugin__countryName.JSON_encode(Geoplugin__response_geoplugin__countryName_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_continentCode");
    enc_len += field_geoplugin__continentCode.JSON_encode(Geoplugin__response_geoplugin__continentCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_latitude");
    enc_len += field_geoplugin__latitude.JSON_encode(Geoplugin__response_geoplugin__latitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_longitude");
    enc_len += field_geoplugin__longitude.JSON_encode(Geoplugin__response_geoplugin__longitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_regionCode");
    enc_len += field_geoplugin__regionCode.JSON_encode(Geoplugin__response_geoplugin__regionCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_regionName");
    enc_len += field_geoplugin__regionName.JSON_encode(Geoplugin__response_geoplugin__regionName_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_currencyCode");
    enc_len += field_geoplugin__currencyCode.JSON_encode(Geoplugin__response_geoplugin__currencyCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_currencySymbol");
    enc_len += field_geoplugin__currencySymbol.JSON_encode(Geoplugin__response_geoplugin__currencySymbol_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_currencySymbol_UTF8");
    enc_len += field_geoplugin__currencySymbol__UTF8.JSON_encode(Geoplugin__response_geoplugin__currencySymbol__UTF8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoplugin_currencyConverter");
    enc_len += field_geoplugin__currencyConverter.JSON_encode(Geoplugin__response_geoplugin__currencyConverter_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Geoplugin__response::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent, int)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  size_t dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  boolean geoplugin__request_found = FALSE;
  boolean geoplugin__status_found = FALSE;
  boolean geoplugin__credit_found = FALSE;
  boolean geoplugin__city_found = FALSE;
  boolean geoplugin__region_found = FALSE;
  boolean geoplugin__areaCode_found = FALSE;
  boolean geoplugin__dmaCode_found = FALSE;
  boolean geoplugin__countryCode_found = FALSE;
  boolean geoplugin__countryName_found = FALSE;
  boolean geoplugin__continentCode_found = FALSE;
  boolean geoplugin__latitude_found = FALSE;
  boolean geoplugin__longitude_found = FALSE;
  boolean geoplugin__regionCode_found = FALSE;
  boolean geoplugin__regionName_found = FALSE;
  boolean geoplugin__currencyCode_found = FALSE;
  boolean geoplugin__currencySymbol_found = FALSE;
  boolean geoplugin__currencySymbol__UTF8_found = FALSE;
  boolean geoplugin__currencyConverter_found = FALSE;

  while (TRUE) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "geoplugin_request", name_len)) {
        geoplugin__request_found = TRUE;
         int ret_val = field_geoplugin__request.JSON_decode(Geoplugin__response_geoplugin__request_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 17, "geoplugin_request");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "geoplugin_status", name_len)) {
        geoplugin__status_found = TRUE;
         int ret_val = field_geoplugin__status.JSON_decode(Geoplugin__response_geoplugin__status_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 16, "geoplugin_status");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "geoplugin_credit", name_len)) {
        geoplugin__credit_found = TRUE;
         int ret_val = field_geoplugin__credit.JSON_decode(Geoplugin__response_geoplugin__credit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 16, "geoplugin_credit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "geoplugin_city", name_len)) {
        geoplugin__city_found = TRUE;
         int ret_val = field_geoplugin__city.JSON_decode(Geoplugin__response_geoplugin__city_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 14, "geoplugin_city");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "geoplugin_region", name_len)) {
        geoplugin__region_found = TRUE;
         int ret_val = field_geoplugin__region.JSON_decode(Geoplugin__response_geoplugin__region_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 16, "geoplugin_region");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "geoplugin_areaCode", name_len)) {
        geoplugin__areaCode_found = TRUE;
         int ret_val = field_geoplugin__areaCode.JSON_decode(Geoplugin__response_geoplugin__areaCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 18, "geoplugin_areaCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "geoplugin_dmaCode", name_len)) {
        geoplugin__dmaCode_found = TRUE;
         int ret_val = field_geoplugin__dmaCode.JSON_decode(Geoplugin__response_geoplugin__dmaCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 17, "geoplugin_dmaCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "geoplugin_countryCode", name_len)) {
        geoplugin__countryCode_found = TRUE;
         int ret_val = field_geoplugin__countryCode.JSON_decode(Geoplugin__response_geoplugin__countryCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 21, "geoplugin_countryCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "geoplugin_countryName", name_len)) {
        geoplugin__countryName_found = TRUE;
         int ret_val = field_geoplugin__countryName.JSON_decode(Geoplugin__response_geoplugin__countryName_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 21, "geoplugin_countryName");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (23 == name_len && 0 == strncmp(fld_name, "geoplugin_continentCode", name_len)) {
        geoplugin__continentCode_found = TRUE;
         int ret_val = field_geoplugin__continentCode.JSON_decode(Geoplugin__response_geoplugin__continentCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 23, "geoplugin_continentCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "geoplugin_latitude", name_len)) {
        geoplugin__latitude_found = TRUE;
         int ret_val = field_geoplugin__latitude.JSON_decode(Geoplugin__response_geoplugin__latitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 18, "geoplugin_latitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "geoplugin_longitude", name_len)) {
        geoplugin__longitude_found = TRUE;
         int ret_val = field_geoplugin__longitude.JSON_decode(Geoplugin__response_geoplugin__longitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 19, "geoplugin_longitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "geoplugin_regionCode", name_len)) {
        geoplugin__regionCode_found = TRUE;
         int ret_val = field_geoplugin__regionCode.JSON_decode(Geoplugin__response_geoplugin__regionCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 20, "geoplugin_regionCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "geoplugin_regionName", name_len)) {
        geoplugin__regionName_found = TRUE;
         int ret_val = field_geoplugin__regionName.JSON_decode(Geoplugin__response_geoplugin__regionName_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 20, "geoplugin_regionName");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "geoplugin_currencyCode", name_len)) {
        geoplugin__currencyCode_found = TRUE;
         int ret_val = field_geoplugin__currencyCode.JSON_decode(Geoplugin__response_geoplugin__currencyCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 22, "geoplugin_currencyCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (24 == name_len && 0 == strncmp(fld_name, "geoplugin_currencySymbol", name_len)) {
        geoplugin__currencySymbol_found = TRUE;
         int ret_val = field_geoplugin__currencySymbol.JSON_decode(Geoplugin__response_geoplugin__currencySymbol_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 24, "geoplugin_currencySymbol");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (29 == name_len && 0 == strncmp(fld_name, "geoplugin_currencySymbol_UTF8", name_len)) {
        geoplugin__currencySymbol__UTF8_found = TRUE;
         int ret_val = field_geoplugin__currencySymbol__UTF8.JSON_decode(Geoplugin__response_geoplugin__currencySymbol__UTF8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 29, "geoplugin_currencySymbol_UTF8");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (27 == name_len && 0 == strncmp(fld_name, "geoplugin_currencyConverter", name_len)) {
        geoplugin__currencyConverter_found = TRUE;
         int ret_val = field_geoplugin__currencyConverter.JSON_decode(Geoplugin__response_geoplugin__currencyConverter_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 27, "geoplugin_currencyConverter");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else {
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, (int)name_len, fld_name);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, (int)name_len, fld_name);
          return JSON_ERROR_FATAL;
        }
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!geoplugin__request_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_request");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__status_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_status");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__credit_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_credit");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__city_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_city");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__region_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_region");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__areaCode_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_areaCode");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__dmaCode_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_dmaCode");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__countryCode_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_countryCode");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__countryName_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_countryName");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__continentCode_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_continentCode");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__latitude_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_latitude");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__longitude_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_longitude");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__regionCode_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_regionCode");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__regionName_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_regionName");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__currencyCode_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_currencyCode");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__currencySymbol_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_currencySymbol");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__currencySymbol__UTF8_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_currencySymbol_UTF8");
    return JSON_ERROR_FATAL;
  }
  if (!geoplugin__currencyConverter_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoplugin_currencyConverter");
    return JSON_ERROR_FATAL;
  }
  
  return (int)dec_len;
}

struct Geoplugin__response_template::single_value_struct {
CHARSTRING_template field_geoplugin__request;
INTEGER_template field_geoplugin__status;
CHARSTRING_template field_geoplugin__credit;
CHARSTRING_template field_geoplugin__city;
CHARSTRING_template field_geoplugin__region;
CHARSTRING_template field_geoplugin__areaCode;
CHARSTRING_template field_geoplugin__dmaCode;
CHARSTRING_template field_geoplugin__countryCode;
CHARSTRING_template field_geoplugin__countryName;
CHARSTRING_template field_geoplugin__continentCode;
CHARSTRING_template field_geoplugin__latitude;
CHARSTRING_template field_geoplugin__longitude;
CHARSTRING_template field_geoplugin__regionCode;
CHARSTRING_template field_geoplugin__regionName;
CHARSTRING_template field_geoplugin__currencyCode;
CHARSTRING_template field_geoplugin__currencySymbol;
CHARSTRING_template field_geoplugin__currencySymbol__UTF8;
FLOAT_template field_geoplugin__currencyConverter;
};

void Geoplugin__response_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_geoplugin__request = ANY_VALUE;
single_value->field_geoplugin__status = ANY_VALUE;
single_value->field_geoplugin__credit = ANY_VALUE;
single_value->field_geoplugin__city = ANY_VALUE;
single_value->field_geoplugin__region = ANY_VALUE;
single_value->field_geoplugin__areaCode = ANY_VALUE;
single_value->field_geoplugin__dmaCode = ANY_VALUE;
single_value->field_geoplugin__countryCode = ANY_VALUE;
single_value->field_geoplugin__countryName = ANY_VALUE;
single_value->field_geoplugin__continentCode = ANY_VALUE;
single_value->field_geoplugin__latitude = ANY_VALUE;
single_value->field_geoplugin__longitude = ANY_VALUE;
single_value->field_geoplugin__regionCode = ANY_VALUE;
single_value->field_geoplugin__regionName = ANY_VALUE;
single_value->field_geoplugin__currencyCode = ANY_VALUE;
single_value->field_geoplugin__currencySymbol = ANY_VALUE;
single_value->field_geoplugin__currencySymbol__UTF8 = ANY_VALUE;
single_value->field_geoplugin__currencyConverter = ANY_VALUE;
}
}
}

void Geoplugin__response_template::copy_value(const Geoplugin__response& other_value)
{
single_value = new single_value_struct;
if (other_value.geoplugin__request().is_bound()) {
  single_value->field_geoplugin__request = other_value.geoplugin__request();
} else {
  single_value->field_geoplugin__request.clean_up();
}
if (other_value.geoplugin__status().is_bound()) {
  single_value->field_geoplugin__status = other_value.geoplugin__status();
} else {
  single_value->field_geoplugin__status.clean_up();
}
if (other_value.geoplugin__credit().is_bound()) {
  single_value->field_geoplugin__credit = other_value.geoplugin__credit();
} else {
  single_value->field_geoplugin__credit.clean_up();
}
if (other_value.geoplugin__city().is_bound()) {
  single_value->field_geoplugin__city = other_value.geoplugin__city();
} else {
  single_value->field_geoplugin__city.clean_up();
}
if (other_value.geoplugin__region().is_bound()) {
  single_value->field_geoplugin__region = other_value.geoplugin__region();
} else {
  single_value->field_geoplugin__region.clean_up();
}
if (other_value.geoplugin__areaCode().is_bound()) {
  single_value->field_geoplugin__areaCode = other_value.geoplugin__areaCode();
} else {
  single_value->field_geoplugin__areaCode.clean_up();
}
if (other_value.geoplugin__dmaCode().is_bound()) {
  single_value->field_geoplugin__dmaCode = other_value.geoplugin__dmaCode();
} else {
  single_value->field_geoplugin__dmaCode.clean_up();
}
if (other_value.geoplugin__countryCode().is_bound()) {
  single_value->field_geoplugin__countryCode = other_value.geoplugin__countryCode();
} else {
  single_value->field_geoplugin__countryCode.clean_up();
}
if (other_value.geoplugin__countryName().is_bound()) {
  single_value->field_geoplugin__countryName = other_value.geoplugin__countryName();
} else {
  single_value->field_geoplugin__countryName.clean_up();
}
if (other_value.geoplugin__continentCode().is_bound()) {
  single_value->field_geoplugin__continentCode = other_value.geoplugin__continentCode();
} else {
  single_value->field_geoplugin__continentCode.clean_up();
}
if (other_value.geoplugin__latitude().is_bound()) {
  single_value->field_geoplugin__latitude = other_value.geoplugin__latitude();
} else {
  single_value->field_geoplugin__latitude.clean_up();
}
if (other_value.geoplugin__longitude().is_bound()) {
  single_value->field_geoplugin__longitude = other_value.geoplugin__longitude();
} else {
  single_value->field_geoplugin__longitude.clean_up();
}
if (other_value.geoplugin__regionCode().is_bound()) {
  single_value->field_geoplugin__regionCode = other_value.geoplugin__regionCode();
} else {
  single_value->field_geoplugin__regionCode.clean_up();
}
if (other_value.geoplugin__regionName().is_bound()) {
  single_value->field_geoplugin__regionName = other_value.geoplugin__regionName();
} else {
  single_value->field_geoplugin__regionName.clean_up();
}
if (other_value.geoplugin__currencyCode().is_bound()) {
  single_value->field_geoplugin__currencyCode = other_value.geoplugin__currencyCode();
} else {
  single_value->field_geoplugin__currencyCode.clean_up();
}
if (other_value.geoplugin__currencySymbol().is_bound()) {
  single_value->field_geoplugin__currencySymbol = other_value.geoplugin__currencySymbol();
} else {
  single_value->field_geoplugin__currencySymbol.clean_up();
}
if (other_value.geoplugin__currencySymbol__UTF8().is_bound()) {
  single_value->field_geoplugin__currencySymbol__UTF8 = other_value.geoplugin__currencySymbol__UTF8();
} else {
  single_value->field_geoplugin__currencySymbol__UTF8.clean_up();
}
if (other_value.geoplugin__currencyConverter().is_bound()) {
  single_value->field_geoplugin__currencyConverter = other_value.geoplugin__currencyConverter();
} else {
  single_value->field_geoplugin__currencyConverter.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Geoplugin__response_template::copy_template(const Geoplugin__response_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__request().get_selection()) {
single_value->field_geoplugin__request = other_value.geoplugin__request();
} else {
single_value->field_geoplugin__request.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__status().get_selection()) {
single_value->field_geoplugin__status = other_value.geoplugin__status();
} else {
single_value->field_geoplugin__status.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__credit().get_selection()) {
single_value->field_geoplugin__credit = other_value.geoplugin__credit();
} else {
single_value->field_geoplugin__credit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__city().get_selection()) {
single_value->field_geoplugin__city = other_value.geoplugin__city();
} else {
single_value->field_geoplugin__city.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__region().get_selection()) {
single_value->field_geoplugin__region = other_value.geoplugin__region();
} else {
single_value->field_geoplugin__region.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__areaCode().get_selection()) {
single_value->field_geoplugin__areaCode = other_value.geoplugin__areaCode();
} else {
single_value->field_geoplugin__areaCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__dmaCode().get_selection()) {
single_value->field_geoplugin__dmaCode = other_value.geoplugin__dmaCode();
} else {
single_value->field_geoplugin__dmaCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__countryCode().get_selection()) {
single_value->field_geoplugin__countryCode = other_value.geoplugin__countryCode();
} else {
single_value->field_geoplugin__countryCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__countryName().get_selection()) {
single_value->field_geoplugin__countryName = other_value.geoplugin__countryName();
} else {
single_value->field_geoplugin__countryName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__continentCode().get_selection()) {
single_value->field_geoplugin__continentCode = other_value.geoplugin__continentCode();
} else {
single_value->field_geoplugin__continentCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__latitude().get_selection()) {
single_value->field_geoplugin__latitude = other_value.geoplugin__latitude();
} else {
single_value->field_geoplugin__latitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__longitude().get_selection()) {
single_value->field_geoplugin__longitude = other_value.geoplugin__longitude();
} else {
single_value->field_geoplugin__longitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__regionCode().get_selection()) {
single_value->field_geoplugin__regionCode = other_value.geoplugin__regionCode();
} else {
single_value->field_geoplugin__regionCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__regionName().get_selection()) {
single_value->field_geoplugin__regionName = other_value.geoplugin__regionName();
} else {
single_value->field_geoplugin__regionName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__currencyCode().get_selection()) {
single_value->field_geoplugin__currencyCode = other_value.geoplugin__currencyCode();
} else {
single_value->field_geoplugin__currencyCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__currencySymbol().get_selection()) {
single_value->field_geoplugin__currencySymbol = other_value.geoplugin__currencySymbol();
} else {
single_value->field_geoplugin__currencySymbol.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__currencySymbol__UTF8().get_selection()) {
single_value->field_geoplugin__currencySymbol__UTF8 = other_value.geoplugin__currencySymbol__UTF8();
} else {
single_value->field_geoplugin__currencySymbol__UTF8.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoplugin__currencyConverter().get_selection()) {
single_value->field_geoplugin__currencyConverter = other_value.geoplugin__currencyConverter();
} else {
single_value->field_geoplugin__currencyConverter.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Geoplugin__response_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @geoplugin.Geoplugin_response.");
break;
}
set_selection(other_value);
}

Geoplugin__response_template::Geoplugin__response_template()
{
}

Geoplugin__response_template::Geoplugin__response_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Geoplugin__response_template::Geoplugin__response_template(const Geoplugin__response& other_value)
{
copy_value(other_value);
}

Geoplugin__response_template::Geoplugin__response_template(const OPTIONAL<Geoplugin__response>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Geoplugin__response&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @geoplugin.Geoplugin_response from an unbound optional field.");
}
}

Geoplugin__response_template::Geoplugin__response_template(const Geoplugin__response_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Geoplugin__response_template::~Geoplugin__response_template()
{
clean_up();
}

Geoplugin__response_template& Geoplugin__response_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Geoplugin__response_template& Geoplugin__response_template::operator=(const Geoplugin__response& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Geoplugin__response_template& Geoplugin__response_template::operator=(const OPTIONAL<Geoplugin__response>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Geoplugin__response&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @geoplugin.Geoplugin_response.");
}
return *this;
}

Geoplugin__response_template& Geoplugin__response_template::operator=(const Geoplugin__response_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Geoplugin__response_template::match(const Geoplugin__response& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.geoplugin__request().is_bound()) return FALSE;
if(!single_value->field_geoplugin__request.match(other_value.geoplugin__request(), legacy))return FALSE;
if(!other_value.geoplugin__status().is_bound()) return FALSE;
if(!single_value->field_geoplugin__status.match(other_value.geoplugin__status(), legacy))return FALSE;
if(!other_value.geoplugin__credit().is_bound()) return FALSE;
if(!single_value->field_geoplugin__credit.match(other_value.geoplugin__credit(), legacy))return FALSE;
if(!other_value.geoplugin__city().is_bound()) return FALSE;
if(!single_value->field_geoplugin__city.match(other_value.geoplugin__city(), legacy))return FALSE;
if(!other_value.geoplugin__region().is_bound()) return FALSE;
if(!single_value->field_geoplugin__region.match(other_value.geoplugin__region(), legacy))return FALSE;
if(!other_value.geoplugin__areaCode().is_bound()) return FALSE;
if(!single_value->field_geoplugin__areaCode.match(other_value.geoplugin__areaCode(), legacy))return FALSE;
if(!other_value.geoplugin__dmaCode().is_bound()) return FALSE;
if(!single_value->field_geoplugin__dmaCode.match(other_value.geoplugin__dmaCode(), legacy))return FALSE;
if(!other_value.geoplugin__countryCode().is_bound()) return FALSE;
if(!single_value->field_geoplugin__countryCode.match(other_value.geoplugin__countryCode(), legacy))return FALSE;
if(!other_value.geoplugin__countryName().is_bound()) return FALSE;
if(!single_value->field_geoplugin__countryName.match(other_value.geoplugin__countryName(), legacy))return FALSE;
if(!other_value.geoplugin__continentCode().is_bound()) return FALSE;
if(!single_value->field_geoplugin__continentCode.match(other_value.geoplugin__continentCode(), legacy))return FALSE;
if(!other_value.geoplugin__latitude().is_bound()) return FALSE;
if(!single_value->field_geoplugin__latitude.match(other_value.geoplugin__latitude(), legacy))return FALSE;
if(!other_value.geoplugin__longitude().is_bound()) return FALSE;
if(!single_value->field_geoplugin__longitude.match(other_value.geoplugin__longitude(), legacy))return FALSE;
if(!other_value.geoplugin__regionCode().is_bound()) return FALSE;
if(!single_value->field_geoplugin__regionCode.match(other_value.geoplugin__regionCode(), legacy))return FALSE;
if(!other_value.geoplugin__regionName().is_bound()) return FALSE;
if(!single_value->field_geoplugin__regionName.match(other_value.geoplugin__regionName(), legacy))return FALSE;
if(!other_value.geoplugin__currencyCode().is_bound()) return FALSE;
if(!single_value->field_geoplugin__currencyCode.match(other_value.geoplugin__currencyCode(), legacy))return FALSE;
if(!other_value.geoplugin__currencySymbol().is_bound()) return FALSE;
if(!single_value->field_geoplugin__currencySymbol.match(other_value.geoplugin__currencySymbol(), legacy))return FALSE;
if(!other_value.geoplugin__currencySymbol__UTF8().is_bound()) return FALSE;
if(!single_value->field_geoplugin__currencySymbol__UTF8.match(other_value.geoplugin__currencySymbol__UTF8(), legacy))return FALSE;
if(!other_value.geoplugin__currencyConverter().is_bound()) return FALSE;
if(!single_value->field_geoplugin__currencyConverter.match(other_value.geoplugin__currencyConverter(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @geoplugin.Geoplugin_response.");
}
return FALSE;
}

boolean Geoplugin__response_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_geoplugin__request.is_bound()) return TRUE;
if (single_value->field_geoplugin__status.is_bound()) return TRUE;
if (single_value->field_geoplugin__credit.is_bound()) return TRUE;
if (single_value->field_geoplugin__city.is_bound()) return TRUE;
if (single_value->field_geoplugin__region.is_bound()) return TRUE;
if (single_value->field_geoplugin__areaCode.is_bound()) return TRUE;
if (single_value->field_geoplugin__dmaCode.is_bound()) return TRUE;
if (single_value->field_geoplugin__countryCode.is_bound()) return TRUE;
if (single_value->field_geoplugin__countryName.is_bound()) return TRUE;
if (single_value->field_geoplugin__continentCode.is_bound()) return TRUE;
if (single_value->field_geoplugin__latitude.is_bound()) return TRUE;
if (single_value->field_geoplugin__longitude.is_bound()) return TRUE;
if (single_value->field_geoplugin__regionCode.is_bound()) return TRUE;
if (single_value->field_geoplugin__regionName.is_bound()) return TRUE;
if (single_value->field_geoplugin__currencyCode.is_bound()) return TRUE;
if (single_value->field_geoplugin__currencySymbol.is_bound()) return TRUE;
if (single_value->field_geoplugin__currencySymbol__UTF8.is_bound()) return TRUE;
if (single_value->field_geoplugin__currencyConverter.is_bound()) return TRUE;
return FALSE;
}

boolean Geoplugin__response_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_geoplugin__request.is_value()) return FALSE;
if (!single_value->field_geoplugin__status.is_value()) return FALSE;
if (!single_value->field_geoplugin__credit.is_value()) return FALSE;
if (!single_value->field_geoplugin__city.is_value()) return FALSE;
if (!single_value->field_geoplugin__region.is_value()) return FALSE;
if (!single_value->field_geoplugin__areaCode.is_value()) return FALSE;
if (!single_value->field_geoplugin__dmaCode.is_value()) return FALSE;
if (!single_value->field_geoplugin__countryCode.is_value()) return FALSE;
if (!single_value->field_geoplugin__countryName.is_value()) return FALSE;
if (!single_value->field_geoplugin__continentCode.is_value()) return FALSE;
if (!single_value->field_geoplugin__latitude.is_value()) return FALSE;
if (!single_value->field_geoplugin__longitude.is_value()) return FALSE;
if (!single_value->field_geoplugin__regionCode.is_value()) return FALSE;
if (!single_value->field_geoplugin__regionName.is_value()) return FALSE;
if (!single_value->field_geoplugin__currencyCode.is_value()) return FALSE;
if (!single_value->field_geoplugin__currencySymbol.is_value()) return FALSE;
if (!single_value->field_geoplugin__currencySymbol__UTF8.is_value()) return FALSE;
if (!single_value->field_geoplugin__currencyConverter.is_value()) return FALSE;
return TRUE;
}

void Geoplugin__response_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Geoplugin__response Geoplugin__response_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @geoplugin.Geoplugin_response.");
Geoplugin__response ret_val;
if (single_value->field_geoplugin__request.is_bound()) {
ret_val.geoplugin__request() = single_value->field_geoplugin__request.valueof();
}
if (single_value->field_geoplugin__status.is_bound()) {
ret_val.geoplugin__status() = single_value->field_geoplugin__status.valueof();
}
if (single_value->field_geoplugin__credit.is_bound()) {
ret_val.geoplugin__credit() = single_value->field_geoplugin__credit.valueof();
}
if (single_value->field_geoplugin__city.is_bound()) {
ret_val.geoplugin__city() = single_value->field_geoplugin__city.valueof();
}
if (single_value->field_geoplugin__region.is_bound()) {
ret_val.geoplugin__region() = single_value->field_geoplugin__region.valueof();
}
if (single_value->field_geoplugin__areaCode.is_bound()) {
ret_val.geoplugin__areaCode() = single_value->field_geoplugin__areaCode.valueof();
}
if (single_value->field_geoplugin__dmaCode.is_bound()) {
ret_val.geoplugin__dmaCode() = single_value->field_geoplugin__dmaCode.valueof();
}
if (single_value->field_geoplugin__countryCode.is_bound()) {
ret_val.geoplugin__countryCode() = single_value->field_geoplugin__countryCode.valueof();
}
if (single_value->field_geoplugin__countryName.is_bound()) {
ret_val.geoplugin__countryName() = single_value->field_geoplugin__countryName.valueof();
}
if (single_value->field_geoplugin__continentCode.is_bound()) {
ret_val.geoplugin__continentCode() = single_value->field_geoplugin__continentCode.valueof();
}
if (single_value->field_geoplugin__latitude.is_bound()) {
ret_val.geoplugin__latitude() = single_value->field_geoplugin__latitude.valueof();
}
if (single_value->field_geoplugin__longitude.is_bound()) {
ret_val.geoplugin__longitude() = single_value->field_geoplugin__longitude.valueof();
}
if (single_value->field_geoplugin__regionCode.is_bound()) {
ret_val.geoplugin__regionCode() = single_value->field_geoplugin__regionCode.valueof();
}
if (single_value->field_geoplugin__regionName.is_bound()) {
ret_val.geoplugin__regionName() = single_value->field_geoplugin__regionName.valueof();
}
if (single_value->field_geoplugin__currencyCode.is_bound()) {
ret_val.geoplugin__currencyCode() = single_value->field_geoplugin__currencyCode.valueof();
}
if (single_value->field_geoplugin__currencySymbol.is_bound()) {
ret_val.geoplugin__currencySymbol() = single_value->field_geoplugin__currencySymbol.valueof();
}
if (single_value->field_geoplugin__currencySymbol__UTF8.is_bound()) {
ret_val.geoplugin__currencySymbol__UTF8() = single_value->field_geoplugin__currencySymbol__UTF8.valueof();
}
if (single_value->field_geoplugin__currencyConverter.is_bound()) {
ret_val.geoplugin__currencyConverter() = single_value->field_geoplugin__currencyConverter.valueof();
}
return ret_val;
}

void Geoplugin__response_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @geoplugin.Geoplugin_response.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Geoplugin__response_template[list_length];
}

Geoplugin__response_template& Geoplugin__response_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @geoplugin.Geoplugin_response.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @geoplugin.Geoplugin_response.");
return value_list.list_value[list_index];
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__request()
{
set_specific();
return single_value->field_geoplugin__request;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__request() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_request of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__request;
}

INTEGER_template& Geoplugin__response_template::geoplugin__status()
{
set_specific();
return single_value->field_geoplugin__status;
}

const INTEGER_template& Geoplugin__response_template::geoplugin__status() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_status of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__status;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__credit()
{
set_specific();
return single_value->field_geoplugin__credit;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__credit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_credit of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__credit;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__city()
{
set_specific();
return single_value->field_geoplugin__city;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__city() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_city of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__city;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__region()
{
set_specific();
return single_value->field_geoplugin__region;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__region() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_region of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__region;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__areaCode()
{
set_specific();
return single_value->field_geoplugin__areaCode;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__areaCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_areaCode of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__areaCode;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__dmaCode()
{
set_specific();
return single_value->field_geoplugin__dmaCode;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__dmaCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_dmaCode of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__dmaCode;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__countryCode()
{
set_specific();
return single_value->field_geoplugin__countryCode;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__countryCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_countryCode of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__countryCode;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__countryName()
{
set_specific();
return single_value->field_geoplugin__countryName;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__countryName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_countryName of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__countryName;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__continentCode()
{
set_specific();
return single_value->field_geoplugin__continentCode;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__continentCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_continentCode of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__continentCode;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__latitude()
{
set_specific();
return single_value->field_geoplugin__latitude;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__latitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_latitude of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__latitude;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__longitude()
{
set_specific();
return single_value->field_geoplugin__longitude;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__longitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_longitude of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__longitude;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__regionCode()
{
set_specific();
return single_value->field_geoplugin__regionCode;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__regionCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_regionCode of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__regionCode;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__regionName()
{
set_specific();
return single_value->field_geoplugin__regionName;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__regionName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_regionName of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__regionName;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__currencyCode()
{
set_specific();
return single_value->field_geoplugin__currencyCode;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__currencyCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_currencyCode of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__currencyCode;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__currencySymbol()
{
set_specific();
return single_value->field_geoplugin__currencySymbol;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__currencySymbol() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_currencySymbol of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__currencySymbol;
}

CHARSTRING_template& Geoplugin__response_template::geoplugin__currencySymbol__UTF8()
{
set_specific();
return single_value->field_geoplugin__currencySymbol__UTF8;
}

const CHARSTRING_template& Geoplugin__response_template::geoplugin__currencySymbol__UTF8() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_currencySymbol_UTF8 of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__currencySymbol__UTF8;
}

FLOAT_template& Geoplugin__response_template::geoplugin__currencyConverter()
{
set_specific();
return single_value->field_geoplugin__currencyConverter;
}

const FLOAT_template& Geoplugin__response_template::geoplugin__currencyConverter() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoplugin_currencyConverter of a non-specific template of type @geoplugin.Geoplugin_response.");
return single_value->field_geoplugin__currencyConverter;
}

int Geoplugin__response_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Geoplugin_response which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 18;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @geoplugin.Geoplugin_response containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Geoplugin_response containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Geoplugin_response containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Geoplugin_response containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Geoplugin_response containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @geoplugin.Geoplugin_response.");
  }
  return 0;
}

void Geoplugin__response_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ geoplugin_request := ");
single_value->field_geoplugin__request.log();
TTCN_Logger::log_event_str(", geoplugin_status := ");
single_value->field_geoplugin__status.log();
TTCN_Logger::log_event_str(", geoplugin_credit := ");
single_value->field_geoplugin__credit.log();
TTCN_Logger::log_event_str(", geoplugin_city := ");
single_value->field_geoplugin__city.log();
TTCN_Logger::log_event_str(", geoplugin_region := ");
single_value->field_geoplugin__region.log();
TTCN_Logger::log_event_str(", geoplugin_areaCode := ");
single_value->field_geoplugin__areaCode.log();
TTCN_Logger::log_event_str(", geoplugin_dmaCode := ");
single_value->field_geoplugin__dmaCode.log();
TTCN_Logger::log_event_str(", geoplugin_countryCode := ");
single_value->field_geoplugin__countryCode.log();
TTCN_Logger::log_event_str(", geoplugin_countryName := ");
single_value->field_geoplugin__countryName.log();
TTCN_Logger::log_event_str(", geoplugin_continentCode := ");
single_value->field_geoplugin__continentCode.log();
TTCN_Logger::log_event_str(", geoplugin_latitude := ");
single_value->field_geoplugin__latitude.log();
TTCN_Logger::log_event_str(", geoplugin_longitude := ");
single_value->field_geoplugin__longitude.log();
TTCN_Logger::log_event_str(", geoplugin_regionCode := ");
single_value->field_geoplugin__regionCode.log();
TTCN_Logger::log_event_str(", geoplugin_regionName := ");
single_value->field_geoplugin__regionName.log();
TTCN_Logger::log_event_str(", geoplugin_currencyCode := ");
single_value->field_geoplugin__currencyCode.log();
TTCN_Logger::log_event_str(", geoplugin_currencySymbol := ");
single_value->field_geoplugin__currencySymbol.log();
TTCN_Logger::log_event_str(", geoplugin_currencySymbol_UTF8 := ");
single_value->field_geoplugin__currencySymbol__UTF8.log();
TTCN_Logger::log_event_str(", geoplugin_currencyConverter := ");
single_value->field_geoplugin__currencyConverter.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Geoplugin__response_template::log_match(const Geoplugin__response& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_geoplugin__request.match(match_value.geoplugin__request(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_request");
single_value->field_geoplugin__request.log_match(match_value.geoplugin__request(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__status.match(match_value.geoplugin__status(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_status");
single_value->field_geoplugin__status.log_match(match_value.geoplugin__status(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__credit.match(match_value.geoplugin__credit(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_credit");
single_value->field_geoplugin__credit.log_match(match_value.geoplugin__credit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__city.match(match_value.geoplugin__city(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_city");
single_value->field_geoplugin__city.log_match(match_value.geoplugin__city(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__region.match(match_value.geoplugin__region(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_region");
single_value->field_geoplugin__region.log_match(match_value.geoplugin__region(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__areaCode.match(match_value.geoplugin__areaCode(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_areaCode");
single_value->field_geoplugin__areaCode.log_match(match_value.geoplugin__areaCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__dmaCode.match(match_value.geoplugin__dmaCode(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_dmaCode");
single_value->field_geoplugin__dmaCode.log_match(match_value.geoplugin__dmaCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__countryCode.match(match_value.geoplugin__countryCode(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_countryCode");
single_value->field_geoplugin__countryCode.log_match(match_value.geoplugin__countryCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__countryName.match(match_value.geoplugin__countryName(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_countryName");
single_value->field_geoplugin__countryName.log_match(match_value.geoplugin__countryName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__continentCode.match(match_value.geoplugin__continentCode(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_continentCode");
single_value->field_geoplugin__continentCode.log_match(match_value.geoplugin__continentCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__latitude.match(match_value.geoplugin__latitude(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_latitude");
single_value->field_geoplugin__latitude.log_match(match_value.geoplugin__latitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__longitude.match(match_value.geoplugin__longitude(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_longitude");
single_value->field_geoplugin__longitude.log_match(match_value.geoplugin__longitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__regionCode.match(match_value.geoplugin__regionCode(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_regionCode");
single_value->field_geoplugin__regionCode.log_match(match_value.geoplugin__regionCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__regionName.match(match_value.geoplugin__regionName(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_regionName");
single_value->field_geoplugin__regionName.log_match(match_value.geoplugin__regionName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__currencyCode.match(match_value.geoplugin__currencyCode(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_currencyCode");
single_value->field_geoplugin__currencyCode.log_match(match_value.geoplugin__currencyCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__currencySymbol.match(match_value.geoplugin__currencySymbol(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_currencySymbol");
single_value->field_geoplugin__currencySymbol.log_match(match_value.geoplugin__currencySymbol(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__currencySymbol__UTF8.match(match_value.geoplugin__currencySymbol__UTF8(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_currencySymbol_UTF8");
single_value->field_geoplugin__currencySymbol__UTF8.log_match(match_value.geoplugin__currencySymbol__UTF8(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoplugin__currencyConverter.match(match_value.geoplugin__currencyConverter(), legacy)){
TTCN_Logger::log_logmatch_info(".geoplugin_currencyConverter");
single_value->field_geoplugin__currencyConverter.log_match(match_value.geoplugin__currencyConverter(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ geoplugin_request := ");
single_value->field_geoplugin__request.log_match(match_value.geoplugin__request(), legacy);
TTCN_Logger::log_event_str(", geoplugin_status := ");
single_value->field_geoplugin__status.log_match(match_value.geoplugin__status(), legacy);
TTCN_Logger::log_event_str(", geoplugin_credit := ");
single_value->field_geoplugin__credit.log_match(match_value.geoplugin__credit(), legacy);
TTCN_Logger::log_event_str(", geoplugin_city := ");
single_value->field_geoplugin__city.log_match(match_value.geoplugin__city(), legacy);
TTCN_Logger::log_event_str(", geoplugin_region := ");
single_value->field_geoplugin__region.log_match(match_value.geoplugin__region(), legacy);
TTCN_Logger::log_event_str(", geoplugin_areaCode := ");
single_value->field_geoplugin__areaCode.log_match(match_value.geoplugin__areaCode(), legacy);
TTCN_Logger::log_event_str(", geoplugin_dmaCode := ");
single_value->field_geoplugin__dmaCode.log_match(match_value.geoplugin__dmaCode(), legacy);
TTCN_Logger::log_event_str(", geoplugin_countryCode := ");
single_value->field_geoplugin__countryCode.log_match(match_value.geoplugin__countryCode(), legacy);
TTCN_Logger::log_event_str(", geoplugin_countryName := ");
single_value->field_geoplugin__countryName.log_match(match_value.geoplugin__countryName(), legacy);
TTCN_Logger::log_event_str(", geoplugin_continentCode := ");
single_value->field_geoplugin__continentCode.log_match(match_value.geoplugin__continentCode(), legacy);
TTCN_Logger::log_event_str(", geoplugin_latitude := ");
single_value->field_geoplugin__latitude.log_match(match_value.geoplugin__latitude(), legacy);
TTCN_Logger::log_event_str(", geoplugin_longitude := ");
single_value->field_geoplugin__longitude.log_match(match_value.geoplugin__longitude(), legacy);
TTCN_Logger::log_event_str(", geoplugin_regionCode := ");
single_value->field_geoplugin__regionCode.log_match(match_value.geoplugin__regionCode(), legacy);
TTCN_Logger::log_event_str(", geoplugin_regionName := ");
single_value->field_geoplugin__regionName.log_match(match_value.geoplugin__regionName(), legacy);
TTCN_Logger::log_event_str(", geoplugin_currencyCode := ");
single_value->field_geoplugin__currencyCode.log_match(match_value.geoplugin__currencyCode(), legacy);
TTCN_Logger::log_event_str(", geoplugin_currencySymbol := ");
single_value->field_geoplugin__currencySymbol.log_match(match_value.geoplugin__currencySymbol(), legacy);
TTCN_Logger::log_event_str(", geoplugin_currencySymbol_UTF8 := ");
single_value->field_geoplugin__currencySymbol__UTF8.log_match(match_value.geoplugin__currencySymbol__UTF8(), legacy);
TTCN_Logger::log_event_str(", geoplugin_currencyConverter := ");
single_value->field_geoplugin__currencyConverter.log_match(match_value.geoplugin__currencyConverter(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Geoplugin__response_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_geoplugin__request.encode_text(text_buf);
single_value->field_geoplugin__status.encode_text(text_buf);
single_value->field_geoplugin__credit.encode_text(text_buf);
single_value->field_geoplugin__city.encode_text(text_buf);
single_value->field_geoplugin__region.encode_text(text_buf);
single_value->field_geoplugin__areaCode.encode_text(text_buf);
single_value->field_geoplugin__dmaCode.encode_text(text_buf);
single_value->field_geoplugin__countryCode.encode_text(text_buf);
single_value->field_geoplugin__countryName.encode_text(text_buf);
single_value->field_geoplugin__continentCode.encode_text(text_buf);
single_value->field_geoplugin__latitude.encode_text(text_buf);
single_value->field_geoplugin__longitude.encode_text(text_buf);
single_value->field_geoplugin__regionCode.encode_text(text_buf);
single_value->field_geoplugin__regionName.encode_text(text_buf);
single_value->field_geoplugin__currencyCode.encode_text(text_buf);
single_value->field_geoplugin__currencySymbol.encode_text(text_buf);
single_value->field_geoplugin__currencySymbol__UTF8.encode_text(text_buf);
single_value->field_geoplugin__currencyConverter.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @geoplugin.Geoplugin_response.");
}
}

void Geoplugin__response_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_geoplugin__request.decode_text(text_buf);
single_value->field_geoplugin__status.decode_text(text_buf);
single_value->field_geoplugin__credit.decode_text(text_buf);
single_value->field_geoplugin__city.decode_text(text_buf);
single_value->field_geoplugin__region.decode_text(text_buf);
single_value->field_geoplugin__areaCode.decode_text(text_buf);
single_value->field_geoplugin__dmaCode.decode_text(text_buf);
single_value->field_geoplugin__countryCode.decode_text(text_buf);
single_value->field_geoplugin__countryName.decode_text(text_buf);
single_value->field_geoplugin__continentCode.decode_text(text_buf);
single_value->field_geoplugin__latitude.decode_text(text_buf);
single_value->field_geoplugin__longitude.decode_text(text_buf);
single_value->field_geoplugin__regionCode.decode_text(text_buf);
single_value->field_geoplugin__regionName.decode_text(text_buf);
single_value->field_geoplugin__currencyCode.decode_text(text_buf);
single_value->field_geoplugin__currencySymbol.decode_text(text_buf);
single_value->field_geoplugin__currencySymbol__UTF8.decode_text(text_buf);
single_value->field_geoplugin__currencyConverter.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Geoplugin__response_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @geoplugin.Geoplugin_response.");
}
}

void Geoplugin__response_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Geoplugin__response_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (18<param.get_size()) {
      param.error("record template of type @geoplugin.Geoplugin_response has 18 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoplugin__request().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoplugin__status().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) geoplugin__credit().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) geoplugin__city().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) geoplugin__region().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) geoplugin__areaCode().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) geoplugin__dmaCode().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) geoplugin__countryCode().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) geoplugin__countryName().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) geoplugin__continentCode().set_param(*param.get_elem(9));
    if (param.get_size()>10 && param.get_elem(10)->get_type()!=Module_Param::MP_NotUsed) geoplugin__latitude().set_param(*param.get_elem(10));
    if (param.get_size()>11 && param.get_elem(11)->get_type()!=Module_Param::MP_NotUsed) geoplugin__longitude().set_param(*param.get_elem(11));
    if (param.get_size()>12 && param.get_elem(12)->get_type()!=Module_Param::MP_NotUsed) geoplugin__regionCode().set_param(*param.get_elem(12));
    if (param.get_size()>13 && param.get_elem(13)->get_type()!=Module_Param::MP_NotUsed) geoplugin__regionName().set_param(*param.get_elem(13));
    if (param.get_size()>14 && param.get_elem(14)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencyCode().set_param(*param.get_elem(14));
    if (param.get_size()>15 && param.get_elem(15)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencySymbol().set_param(*param.get_elem(15));
    if (param.get_size()>16 && param.get_elem(16)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencySymbol__UTF8().set_param(*param.get_elem(16));
    if (param.get_size()>17 && param.get_elem(17)->get_type()!=Module_Param::MP_NotUsed) geoplugin__currencyConverter().set_param(*param.get_elem(17));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_request")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__request().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_status")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__status().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_credit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__credit().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_city")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__city().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__region().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_areaCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__areaCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_dmaCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__dmaCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_countryCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__countryCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_countryName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__countryName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_continentCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__continentCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__latitude().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__longitude().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_regionCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__regionCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_regionName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__regionName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencyCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencyCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencySymbol")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencySymbol().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencySymbol_UTF8")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencySymbol__UTF8().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoplugin_currencyConverter")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoplugin__currencyConverter().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @geoplugin.Geoplugin_response: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@geoplugin.Geoplugin_response");
  }
  is_ifpresent = param.get_ifpresent();
}

void Geoplugin__response_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_geoplugin__request.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__status.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__credit.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__city.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__region.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__areaCode.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__dmaCode.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__countryCode.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__countryName.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__continentCode.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__latitude.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__longitude.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__regionCode.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__regionName.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__currencyCode.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__currencySymbol.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__currencySymbol__UTF8.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
single_value->field_geoplugin__currencyConverter.check_restriction(t_res, t_name ? t_name : "@geoplugin.Geoplugin_response");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@geoplugin.Geoplugin_response");
}

boolean Geoplugin__response_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Geoplugin__response_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Memory__response::Memory__response()
{
}

Memory__response::Memory__response(const INTEGER& par_memoryValueAvailable,
    const INTEGER& par_memoryValueSwapTotal,
    const INTEGER& par_memoryValueSwapUsed)
  :   field_memoryValueAvailable(par_memoryValueAvailable),
  field_memoryValueSwapTotal(par_memoryValueSwapTotal),
  field_memoryValueSwapUsed(par_memoryValueSwapUsed)
{
}

Memory__response::Memory__response(const Memory__response& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @geoplugin.Memory_response.");
if (other_value.memoryValueAvailable().is_bound()) field_memoryValueAvailable = other_value.memoryValueAvailable();
else field_memoryValueAvailable.clean_up();
if (other_value.memoryValueSwapTotal().is_bound()) field_memoryValueSwapTotal = other_value.memoryValueSwapTotal();
else field_memoryValueSwapTotal.clean_up();
if (other_value.memoryValueSwapUsed().is_bound()) field_memoryValueSwapUsed = other_value.memoryValueSwapUsed();
else field_memoryValueSwapUsed.clean_up();
}

void Memory__response::clean_up()
{
field_memoryValueAvailable.clean_up();
field_memoryValueSwapTotal.clean_up();
field_memoryValueSwapUsed.clean_up();
}

const TTCN_Typedescriptor_t* Memory__response::get_descriptor() const { return &Memory__response_descr_; }
Memory__response& Memory__response::operator=(const Memory__response& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @geoplugin.Memory_response.");
  if (other_value.memoryValueAvailable().is_bound()) field_memoryValueAvailable = other_value.memoryValueAvailable();
  else field_memoryValueAvailable.clean_up();
  if (other_value.memoryValueSwapTotal().is_bound()) field_memoryValueSwapTotal = other_value.memoryValueSwapTotal();
  else field_memoryValueSwapTotal.clean_up();
  if (other_value.memoryValueSwapUsed().is_bound()) field_memoryValueSwapUsed = other_value.memoryValueSwapUsed();
  else field_memoryValueSwapUsed.clean_up();
}
return *this;
}

boolean Memory__response::operator==(const Memory__response& other_value) const
{
return field_memoryValueAvailable==other_value.field_memoryValueAvailable
  && field_memoryValueSwapTotal==other_value.field_memoryValueSwapTotal
  && field_memoryValueSwapUsed==other_value.field_memoryValueSwapUsed;
}

boolean Memory__response::is_bound() const
{
if(field_memoryValueAvailable.is_bound()) return TRUE;
if(field_memoryValueSwapTotal.is_bound()) return TRUE;
if(field_memoryValueSwapUsed.is_bound()) return TRUE;
return FALSE;
}
boolean Memory__response::is_value() const
{
if(!field_memoryValueAvailable.is_value()) return FALSE;
if(!field_memoryValueSwapTotal.is_value()) return FALSE;
if(!field_memoryValueSwapUsed.is_value()) return FALSE;
return TRUE;
}
void Memory__response::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ memoryValueAvailable := ");
field_memoryValueAvailable.log();
TTCN_Logger::log_event_str(", memoryValueSwapTotal := ");
field_memoryValueSwapTotal.log();
TTCN_Logger::log_event_str(", memoryValueSwapUsed := ");
field_memoryValueSwapUsed.log();
TTCN_Logger::log_event_str(" }");
}

void Memory__response::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @geoplugin.Memory_response has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) memoryValueAvailable().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) memoryValueSwapTotal().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) memoryValueSwapUsed().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "memoryValueAvailable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          memoryValueAvailable().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "memoryValueSwapTotal")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          memoryValueSwapTotal().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "memoryValueSwapUsed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          memoryValueSwapUsed().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @geoplugin.Memory_response: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@geoplugin.Memory_response");
  }
}

void Memory__response::set_implicit_omit()
{
if (memoryValueAvailable().is_bound()) memoryValueAvailable().set_implicit_omit();
if (memoryValueSwapTotal().is_bound()) memoryValueSwapTotal().set_implicit_omit();
if (memoryValueSwapUsed().is_bound()) memoryValueSwapUsed().set_implicit_omit();
}

void Memory__response::encode_text(Text_Buf& text_buf) const
{
field_memoryValueAvailable.encode_text(text_buf);
field_memoryValueSwapTotal.encode_text(text_buf);
field_memoryValueSwapUsed.encode_text(text_buf);
}

void Memory__response::decode_text(Text_Buf& text_buf)
{
field_memoryValueAvailable.decode_text(text_buf);
field_memoryValueSwapTotal.decode_text(text_buf);
field_memoryValueSwapUsed.decode_text(text_buf);
}

void Memory__response::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-encoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
    OER_encode(p_td, p_buf);
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Memory__response::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  case TTCN_EncDec::CT_OER: {
    TTCN_EncDec_ErrorContext ec("While OER-decoding type '%s': ", p_td.name);
    if(!p_td.oer)
      TTCN_EncDec_ErrorContext::error_internal
        ("No OER descriptor available for type '%s'.", p_td.name);
     OER_struct p_oer;
    OER_decode(p_td, p_buf, p_oer);
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Memory__response::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @geoplugin.Memory_response.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "memoryValueAvailable");
    enc_len += field_memoryValueAvailable.JSON_encode(Memory__response_memoryValueAvailable_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "memoryValueSwapTotal");
    enc_len += field_memoryValueSwapTotal.JSON_encode(Memory__response_memoryValueSwapTotal_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "memoryValueSwapUsed");
    enc_len += field_memoryValueSwapUsed.JSON_encode(Memory__response_memoryValueSwapUsed_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Memory__response::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent, int)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  size_t dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  boolean memoryValueAvailable_found = FALSE;
  boolean memoryValueSwapTotal_found = FALSE;
  boolean memoryValueSwapUsed_found = FALSE;

  while (TRUE) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (20 == name_len && 0 == strncmp(fld_name, "memoryValueAvailable", name_len)) {
        memoryValueAvailable_found = TRUE;
         int ret_val = field_memoryValueAvailable.JSON_decode(Memory__response_memoryValueAvailable_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 20, "memoryValueAvailable");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "memoryValueSwapTotal", name_len)) {
        memoryValueSwapTotal_found = TRUE;
         int ret_val = field_memoryValueSwapTotal.JSON_decode(Memory__response_memoryValueSwapTotal_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 20, "memoryValueSwapTotal");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "memoryValueSwapUsed", name_len)) {
        memoryValueSwapUsed_found = TRUE;
         int ret_val = field_memoryValueSwapUsed.JSON_decode(Memory__response_memoryValueSwapUsed_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 19, "memoryValueSwapUsed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += (size_t)ret_val;
      }
      else {
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, (int)name_len, fld_name);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, (int)name_len, fld_name);
          return JSON_ERROR_FATAL;
        }
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!memoryValueAvailable_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "memoryValueAvailable");
    return JSON_ERROR_FATAL;
  }
  if (!memoryValueSwapTotal_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "memoryValueSwapTotal");
    return JSON_ERROR_FATAL;
  }
  if (!memoryValueSwapUsed_found) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "memoryValueSwapUsed");
    return JSON_ERROR_FATAL;
  }
  
  return (int)dec_len;
}

struct Memory__response_template::single_value_struct {
INTEGER_template field_memoryValueAvailable;
INTEGER_template field_memoryValueSwapTotal;
INTEGER_template field_memoryValueSwapUsed;
};

void Memory__response_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_memoryValueAvailable = ANY_VALUE;
single_value->field_memoryValueSwapTotal = ANY_VALUE;
single_value->field_memoryValueSwapUsed = ANY_VALUE;
}
}
}

void Memory__response_template::copy_value(const Memory__response& other_value)
{
single_value = new single_value_struct;
if (other_value.memoryValueAvailable().is_bound()) {
  single_value->field_memoryValueAvailable = other_value.memoryValueAvailable();
} else {
  single_value->field_memoryValueAvailable.clean_up();
}
if (other_value.memoryValueSwapTotal().is_bound()) {
  single_value->field_memoryValueSwapTotal = other_value.memoryValueSwapTotal();
} else {
  single_value->field_memoryValueSwapTotal.clean_up();
}
if (other_value.memoryValueSwapUsed().is_bound()) {
  single_value->field_memoryValueSwapUsed = other_value.memoryValueSwapUsed();
} else {
  single_value->field_memoryValueSwapUsed.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Memory__response_template::copy_template(const Memory__response_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.memoryValueAvailable().get_selection()) {
single_value->field_memoryValueAvailable = other_value.memoryValueAvailable();
} else {
single_value->field_memoryValueAvailable.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.memoryValueSwapTotal().get_selection()) {
single_value->field_memoryValueSwapTotal = other_value.memoryValueSwapTotal();
} else {
single_value->field_memoryValueSwapTotal.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.memoryValueSwapUsed().get_selection()) {
single_value->field_memoryValueSwapUsed = other_value.memoryValueSwapUsed();
} else {
single_value->field_memoryValueSwapUsed.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Memory__response_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @geoplugin.Memory_response.");
break;
}
set_selection(other_value);
}

Memory__response_template::Memory__response_template()
{
}

Memory__response_template::Memory__response_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Memory__response_template::Memory__response_template(const Memory__response& other_value)
{
copy_value(other_value);
}

Memory__response_template::Memory__response_template(const OPTIONAL<Memory__response>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Memory__response&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @geoplugin.Memory_response from an unbound optional field.");
}
}

Memory__response_template::Memory__response_template(const Memory__response_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Memory__response_template::~Memory__response_template()
{
clean_up();
}

Memory__response_template& Memory__response_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Memory__response_template& Memory__response_template::operator=(const Memory__response& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Memory__response_template& Memory__response_template::operator=(const OPTIONAL<Memory__response>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Memory__response&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @geoplugin.Memory_response.");
}
return *this;
}

Memory__response_template& Memory__response_template::operator=(const Memory__response_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Memory__response_template::match(const Memory__response& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.memoryValueAvailable().is_bound()) return FALSE;
if(!single_value->field_memoryValueAvailable.match(other_value.memoryValueAvailable(), legacy))return FALSE;
if(!other_value.memoryValueSwapTotal().is_bound()) return FALSE;
if(!single_value->field_memoryValueSwapTotal.match(other_value.memoryValueSwapTotal(), legacy))return FALSE;
if(!other_value.memoryValueSwapUsed().is_bound()) return FALSE;
if(!single_value->field_memoryValueSwapUsed.match(other_value.memoryValueSwapUsed(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @geoplugin.Memory_response.");
}
return FALSE;
}

boolean Memory__response_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_memoryValueAvailable.is_bound()) return TRUE;
if (single_value->field_memoryValueSwapTotal.is_bound()) return TRUE;
if (single_value->field_memoryValueSwapUsed.is_bound()) return TRUE;
return FALSE;
}

boolean Memory__response_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_memoryValueAvailable.is_value()) return FALSE;
if (!single_value->field_memoryValueSwapTotal.is_value()) return FALSE;
if (!single_value->field_memoryValueSwapUsed.is_value()) return FALSE;
return TRUE;
}

void Memory__response_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Memory__response Memory__response_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @geoplugin.Memory_response.");
Memory__response ret_val;
if (single_value->field_memoryValueAvailable.is_bound()) {
ret_val.memoryValueAvailable() = single_value->field_memoryValueAvailable.valueof();
}
if (single_value->field_memoryValueSwapTotal.is_bound()) {
ret_val.memoryValueSwapTotal() = single_value->field_memoryValueSwapTotal.valueof();
}
if (single_value->field_memoryValueSwapUsed.is_bound()) {
ret_val.memoryValueSwapUsed() = single_value->field_memoryValueSwapUsed.valueof();
}
return ret_val;
}

void Memory__response_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @geoplugin.Memory_response.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Memory__response_template[list_length];
}

Memory__response_template& Memory__response_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @geoplugin.Memory_response.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @geoplugin.Memory_response.");
return value_list.list_value[list_index];
}

INTEGER_template& Memory__response_template::memoryValueAvailable()
{
set_specific();
return single_value->field_memoryValueAvailable;
}

const INTEGER_template& Memory__response_template::memoryValueAvailable() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field memoryValueAvailable of a non-specific template of type @geoplugin.Memory_response.");
return single_value->field_memoryValueAvailable;
}

INTEGER_template& Memory__response_template::memoryValueSwapTotal()
{
set_specific();
return single_value->field_memoryValueSwapTotal;
}

const INTEGER_template& Memory__response_template::memoryValueSwapTotal() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field memoryValueSwapTotal of a non-specific template of type @geoplugin.Memory_response.");
return single_value->field_memoryValueSwapTotal;
}

INTEGER_template& Memory__response_template::memoryValueSwapUsed()
{
set_specific();
return single_value->field_memoryValueSwapUsed;
}

const INTEGER_template& Memory__response_template::memoryValueSwapUsed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field memoryValueSwapUsed of a non-specific template of type @geoplugin.Memory_response.");
return single_value->field_memoryValueSwapUsed;
}

int Memory__response_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Memory_response which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @geoplugin.Memory_response containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Memory_response containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Memory_response containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Memory_response containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @geoplugin.Memory_response containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @geoplugin.Memory_response.");
  }
  return 0;
}

void Memory__response_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ memoryValueAvailable := ");
single_value->field_memoryValueAvailable.log();
TTCN_Logger::log_event_str(", memoryValueSwapTotal := ");
single_value->field_memoryValueSwapTotal.log();
TTCN_Logger::log_event_str(", memoryValueSwapUsed := ");
single_value->field_memoryValueSwapUsed.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Memory__response_template::log_match(const Memory__response& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_memoryValueAvailable.match(match_value.memoryValueAvailable(), legacy)){
TTCN_Logger::log_logmatch_info(".memoryValueAvailable");
single_value->field_memoryValueAvailable.log_match(match_value.memoryValueAvailable(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_memoryValueSwapTotal.match(match_value.memoryValueSwapTotal(), legacy)){
TTCN_Logger::log_logmatch_info(".memoryValueSwapTotal");
single_value->field_memoryValueSwapTotal.log_match(match_value.memoryValueSwapTotal(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_memoryValueSwapUsed.match(match_value.memoryValueSwapUsed(), legacy)){
TTCN_Logger::log_logmatch_info(".memoryValueSwapUsed");
single_value->field_memoryValueSwapUsed.log_match(match_value.memoryValueSwapUsed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ memoryValueAvailable := ");
single_value->field_memoryValueAvailable.log_match(match_value.memoryValueAvailable(), legacy);
TTCN_Logger::log_event_str(", memoryValueSwapTotal := ");
single_value->field_memoryValueSwapTotal.log_match(match_value.memoryValueSwapTotal(), legacy);
TTCN_Logger::log_event_str(", memoryValueSwapUsed := ");
single_value->field_memoryValueSwapUsed.log_match(match_value.memoryValueSwapUsed(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Memory__response_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_memoryValueAvailable.encode_text(text_buf);
single_value->field_memoryValueSwapTotal.encode_text(text_buf);
single_value->field_memoryValueSwapUsed.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @geoplugin.Memory_response.");
}
}

void Memory__response_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_memoryValueAvailable.decode_text(text_buf);
single_value->field_memoryValueSwapTotal.decode_text(text_buf);
single_value->field_memoryValueSwapUsed.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Memory__response_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @geoplugin.Memory_response.");
}
}

void Memory__response_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Memory__response_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @geoplugin.Memory_response has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) memoryValueAvailable().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) memoryValueSwapTotal().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) memoryValueSwapUsed().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "memoryValueAvailable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          memoryValueAvailable().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "memoryValueSwapTotal")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          memoryValueSwapTotal().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "memoryValueSwapUsed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          memoryValueSwapUsed().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @geoplugin.Memory_response: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@geoplugin.Memory_response");
  }
  is_ifpresent = param.get_ifpresent();
}

void Memory__response_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_memoryValueAvailable.check_restriction(t_res, t_name ? t_name : "@geoplugin.Memory_response");
single_value->field_memoryValueSwapTotal.check_restriction(t_res, t_name ? t_name : "@geoplugin.Memory_response");
single_value->field_memoryValueSwapUsed.check_restriction(t_res, t_name ? t_name : "@geoplugin.Memory_response");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@geoplugin.Memory_response");
}

boolean Memory__response_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Memory__response_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

OCTETSTRING enc__JSON(const JSON__PDU& msg)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("enc_JSON(): Encoding @geoplugin.JSON_PDU: ");
msg.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_ERROR);
TTCN_Buffer ttcn_buffer;
msg.encode(JSON__PDU_descr_, ttcn_buffer, TTCN_EncDec::CT_JSON, 1);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("enc_JSON(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

JSON__PDU dec__JSON(const OCTETSTRING& p__stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("dec_JSON(): Stream before decoding: ");
p__stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_ERROR);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(p__stream);
JSON__PDU ret_val;
ret_val.decode(JSON__PDU_descr_, ttcn_buffer, TTCN_EncDec::CT_JSON);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("dec_JSON(): Decoded @geoplugin.JSON_PDU: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len() && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("dec_JSON(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

void Geoplugin__response_geoplugin__request_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__request_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__request_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__request_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__status_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__status_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__status_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__status_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__credit_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__credit_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__credit_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__credit_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__city_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__city_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__city_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__city_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__region_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__region_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__region_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__region_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__areaCode_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__areaCode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__areaCode_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__areaCode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__dmaCode_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__dmaCode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__dmaCode_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__dmaCode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__countryCode_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__countryCode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__countryCode_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__countryCode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__countryName_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__countryName_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__countryName_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__countryName_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__continentCode_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__continentCode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__continentCode_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__continentCode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__latitude_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__latitude_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__latitude_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__latitude_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__longitude_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__longitude_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__longitude_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__longitude_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__regionCode_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__regionCode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__regionCode_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__regionCode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__regionName_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__regionName_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__regionName_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__regionName_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__currencyCode_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__currencyCode_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__currencyCode_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__currencyCode_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__currencySymbol_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__currencySymbol_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__currencySymbol_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__currencySymbol_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__currencySymbol__UTF8_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__currencySymbol__UTF8_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__currencySymbol__UTF8_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `charstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__currencySymbol__UTF8_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_geoplugin__currencyConverter_encoder(const FLOAT& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `float' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_geoplugin__currencyConverter_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_geoplugin__currencyConverter_decoder(OCTETSTRING& input_stream, FLOAT& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `float' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_geoplugin__currencyConverter_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Geoplugin__response_encoder(const Geoplugin__response& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@geoplugin.Geoplugin_response' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Geoplugin__response_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Geoplugin__response_decoder(OCTETSTRING& input_stream, Geoplugin__response& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@geoplugin.Geoplugin_response' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Geoplugin__response_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Memory__response_memoryValueAvailable_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Memory__response_memoryValueAvailable_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Memory__response_memoryValueAvailable_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Memory__response_memoryValueAvailable_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Memory__response_memoryValueSwapTotal_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Memory__response_memoryValueSwapTotal_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Memory__response_memoryValueSwapTotal_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Memory__response_memoryValueSwapTotal_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Memory__response_memoryValueSwapUsed_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Memory__response_memoryValueSwapUsed_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Memory__response_memoryValueSwapUsed_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `integer' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Memory__response_memoryValueSwapUsed_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void Memory__response_encoder(const Memory__response& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@geoplugin.Memory_response' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(Memory__response_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER Memory__response_decoder(OCTETSTRING& input_stream, Memory__response& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@geoplugin.Memory_response' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(Memory__response_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}

void JSON__PDU_encoder(const JSON__PDU& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@geoplugin.JSON_PDU' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(JSON__PDU_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER JSON__PDU_decoder(OCTETSTRING& input_stream, JSON__PDU& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `@geoplugin.JSON_PDU' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(JSON__PDU_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}


/* Bodies of static functions */

static void pre_init_module()
{
module_object.add_function("enc_JSON", (genericfunc_t)&enc__JSON, NULL);
module_object.add_function("dec_JSON", (genericfunc_t)&dec__JSON, NULL);
}


} /* end of namespace */
