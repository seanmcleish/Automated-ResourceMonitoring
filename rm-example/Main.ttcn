module Main {

type record of KeyValueInteger IntegerDictionary;
type record of KeyValueFloat FloatDictionary;

type record RegressionParameter
{
  float slopeParameter,		// Steigung
  float interceptParameter 	// Niveau
}

type union Number
{
  integer asInteger,
  float asFloat
}

type record KeyValueInteger
{
  integer Key,
  integer Value
}

type record KeyValueFloat
{
  integer Key,
  float Value
}

import from HTTPmsg_Types all;

import from RESTModul all;
import from JSONModul all;

function ContentLength (in charstring par_body) return charstring
{
  var charstring a:=int2str(lengthof (par_body))
  return a;
}

function log_debug(in charstring p_message)
{
  log("DEBUG - " & p_message);
}

function DatestringToRoughlySeconds (in charstring p_date) return integer
{
  var integer year := str2int(regexp(p_date, "(\d*)-(\d*)-(\d*)T(\d*):(\d*):(\d*).(\d*)", 0));
  var integer month := str2int(regexp(p_date, "(\d*)-(\d*)-(\d*)T(\d*):(\d*):(\d*).(\d*)", 1));
  var integer days := str2int(regexp(p_date, "(\d*)-(\d*)-(\d*)T(\d*):(\d*):(\d*).(\d*)", 2));
  var integer hours := str2int(regexp(p_date, "(\d*)-(\d*)-(\d*)T(\d*):(\d*):(\d*).(\d*)", 3));
  var integer minutes := str2int(regexp(p_date, "(\d*)-(\d*)-(\d*)T(\d*):(\d*):(\d*).(\d*)", 4));
  var integer seconds := str2int(regexp(p_date, "(\d*)-(\d*)-(\d*)T(\d*):(\d*):(\d*).(\d*)", 5));
  return year*31536000+month*2628000+days*86400+hours*3600+minutes*60+seconds;
}

function CalculateRegressionInteger (in IntegerDictionary p_values) runs on TestComponent return RegressionParameter
{
  var float slope:=0.0;				// Steigung
  var float intercept:=0.0;			// Niveau
  var float averageCounter := 0.0;
  var float averageValue := 0.0;
  if(lengthof(p_values)<1)
  {
      slope := not_a_number;
      intercept := not_a_number;
  }
  else
  {
      // Calculate average
      for(var integer i := 0; i<lengthof(p_values); i := i+1)
      {
        averageCounter := averageCounter + int2float(p_values[i].Key);
        averageValue := averageValue + int2float(p_values[i].Value);
      }
      averageCounter := averageCounter / int2float(lengthof(p_values));
      averageValue := averageValue / int2float(lengthof(p_values));
      
      // Calculate slope
      var float slope1 := 0.0;
      var float slope2 := 0.0;
      for(var integer i := 0; i<lengthof(p_values); i := i+1)
      {
        // Numerator
        slope1 := slope1 + (int2float(p_values[i].Key)-averageCounter)*(int2float(p_values[i].Value)-averageValue);
        // Denominator
        slope2 := slope2 + (int2float(p_values[i].Key)-averageCounter)*(int2float(p_values[i].Key)-averageCounter);
      }
      slope := slope1;
      if(slope2==0.0)
      {
        slope := 0.0;
      }
      else
      {
        slope := slope1/slope2;
      }
      intercept := averageValue-slope*averageCounter;
  	}
  	log("Slope: "& float2str(slope) & " Intercept: "&float2str(intercept) );
  	return {slope, intercept};
  }
  
  function CalculateRegressionFloat (in FloatDictionary p_values) runs on TestComponent return RegressionParameter
  {
    var float slope:=0.0;				// Steigung
    var float intercept:=0.0;			// Niveau
    var float averageCounter := 0.0;
    var float averageValue := 0.0;
    if(lengthof(p_values)<1)
    {
        slope := not_a_number;
        intercept := not_a_number;
    }
    else
    {
        // Calculate average
        for(var integer i := 0; i<lengthof(p_values); i := i+1)
        {
          averageCounter := averageCounter + int2float(p_values[i].Key);
          averageValue := averageValue + p_values[i].Value;
        }
        averageCounter := averageCounter / int2float(lengthof(p_values));
        averageValue := averageValue / int2float(lengthof(p_values));
        
        // Calculate slope
        var float slope1 := 0.0;
        var float slope2 := 0.0;
        for(var integer i := 0; i<lengthof(p_values); i := i+1)
        {
          // Numerator
          slope1 := slope1 + (int2float(p_values[i].Key)-averageCounter)*(p_values[i].Value-averageValue);
          // Denominator
          slope2 := slope2 + (int2float(p_values[i].Key)-averageCounter)*(int2float(p_values[i].Key)-averageCounter);
        }
        slope := slope1;
        if(slope2==0.0)
        {
          slope := 0.0;
        }
        else
        {
          slope := slope1/slope2;
        }
        intercept := averageValue-slope*averageCounter;
        log("Slope: "& float2str(slope) & " Intercept: "&float2str(intercept) );
  	}
  return {slope, intercept};
}

testcase tc_createDataByHostname(in ServiceInstance p_serviceInstance, in charstring p_sensorHostname, in integer p_sensorPortnumber, out JSONObject.Measurement result)
runs on TestComponent system TestComponent
{
  map(self:TestPort, system:TestPort);
  log_debug("Creating data for sensor=\"" & p_sensorHostname & "\" on service=\"" & p_serviceInstance.hostname);
  var template HTTPMessage post_request := t_POST_Request("/createDataByHostName?hostName="&p_sensorHostname&"&remotePort="&int2str(p_sensorPortnumber));
  var JSONObject response := SendRESTRequest(p_serviceInstance, post_request);
  if(ischosen(response.Measurement))
  {
    setverdict(pass);
    result:=response.Measurement;
    log_debug("Created measurement with id " & int2str(result.measurementId));
  }
  else
  {
    setverdict(none);
  }
}

testcase tc_stopMeasurementByMeasurementId(in ServiceInstance p_serviceInstance, in integer p_measurementId)
runs on TestComponent system TestComponent
{
  map(self:TestPort, system:TestPort);
  var template HTTPMessage post_request := t_PUT_Request("/measurement/" & int2str(p_measurementId) & "?measurementRunning=false");
  var JSONObject response := SendRESTRequest(p_serviceInstance, post_request);
  if(ischosen(response.Measurement))
  {
    setverdict(pass);
    log_debug("Stopped measurement with id " & int2str(response.Measurement.measurementId));
  }
  else
  {
    setverdict(none);
  }
}


testcase tc_getMeasurementSystemByMeasurementId(in ServiceInstance p_serviceInstance, in integer p_measurementId, out JSONObject.SystemObject p_result)
runs on TestComponent
{
  map(self:TestPort, system:TestPort);
  var template HTTPMessage get_request := t_GET_Request( "/measurement/"&int2str(p_measurementId)& "/measurementSystem");
  var JSONObject response := SendRESTRequest(p_serviceInstance, get_request);
  if(ischosen(response.SystemObject))
  {
    setverdict(pass);
    p_result:=response.SystemObject;
    log_debug("Retrieved system with id " & int2str(p_result.systemIdentifier));
  }
  else
  {
    setverdict(none);
  }
}


testcase tc_createProcessesWithMeasurementId(in ServiceInstance p_serviceInstance, in integer p_measurementId, in JSONObject.Process p_process, out JSONObject.Processes p_result)
runs on TestComponent
{
  map(self:TestPort, system:TestPort);
  var template HTTPMessage post_request := t_POST_Request( "/process?measurementId="&int2str(p_measurementId)&"&processName="&p_process.processName);
  var JSONObject response := SendRESTRequest(p_serviceInstance, post_request);
  if(ischosen(response.Processes))
  {
    setverdict(pass);
    p_result:=response.Processes;
    for(var integer i := 0; i<lengthof(p_result); i := i+1)
    {
      log_debug("Created process \"" & p_result[i].processName & "\" with PID " & int2str(p_result[i].processPid));
    }
    log()
  }
  else
  {
    setverdict(none);
  }
}

// MEMORY

testcase tc_memoryAvailableLowerThan(in ServiceInstance p_serviceInstance, in integer p_measurementId, in integer p_memoryTotalSpace, in float p_relativeLowerBound) 
runs on TestComponent 
{
  var template HTTPMessage get_request := t_GET_Request( "/memory/"&int2str(p_memoryTotalSpace)&"/memoryValues/"&int2str(p_measurementId));
  var JSONObject result := SendRESTRequest(p_serviceInstance, get_request);
  if(not(ischosen(result.memoryValues)))
  {
    stop;
  }
  setverdict(pass);
  log_debug("Testing if available memory in measurement with id " & int2str(p_measurementId) & " fall below " & float2str(p_relativeLowerBound));
  for(var integer i := 0; i < lengthof(result.memoryValues); i := i+1)
  {
    if((int2float(result.memoryValues[i].memoryValueAvailable)/int2float(p_memoryTotalSpace)) < p_relativeLowerBound)
    {
      setverdict(fail);
    }
  }
}

// PROCESSOR

testcase tc_processorUsageSinceStartGreaterThan(in ServiceInstance p_serviceInstance, in integer p_measurementId, in charstring p_processorId, in float p_relativeUpperBound) 
runs on TestComponent 
{
  var template HTTPMessage get_request := t_GET_Request( "/processor/"&p_processorId&"/processorValues/"&int2str(p_measurementId));
  var JSONObject result := SendRESTRequest(p_serviceInstance, get_request);
  if(not(ischosen(result.processorValues)))
  {
    stop;
  }
  if(lengthof(result.processorValues) < 2)
  {
    stop;
  }
  setverdict(pass);
  log_debug("Testing if cpu usage since start in measurement with id " & int2str(p_measurementId) & " is greater than " & float2str(p_relativeUpperBound));
  var JSONObject.processorValue v_firstValue := result.processorValues[0];
  var JSONObject.processorValue v_lastValue := result.processorValues[lengthof(result.processorValues)-1];
  var integer v_totalTicks_first := 	v_firstValue .processorValueSystemCpuLoadTicks[0]
  									+ 	v_firstValue .processorValueSystemCpuLoadTicks[1]
  									+ 	v_firstValue .processorValueSystemCpuLoadTicks[2]
  									+ 	v_firstValue .processorValueSystemCpuLoadTicks[3]
  									+ 	v_firstValue .processorValueSystemCpuLoadTicks[4]
  									+ 	v_firstValue .processorValueSystemCpuLoadTicks[5]
  									+ 	v_firstValue .processorValueSystemCpuLoadTicks[6]
  									+ 	v_firstValue .processorValueSystemCpuLoadTicks[7];
  									
  var integer v_totalTicks_last := 		v_lastValue .processorValueSystemCpuLoadTicks[0]
  									+ 	v_lastValue .processorValueSystemCpuLoadTicks[1]
  									+ 	v_lastValue .processorValueSystemCpuLoadTicks[2]
  									+ 	v_lastValue .processorValueSystemCpuLoadTicks[3]
  									+ 	v_lastValue .processorValueSystemCpuLoadTicks[4]
  									+ 	v_lastValue .processorValueSystemCpuLoadTicks[5]
  									+ 	v_lastValue .processorValueSystemCpuLoadTicks[6]
  									+ 	v_lastValue .processorValueSystemCpuLoadTicks[7];
  var integer v_idleTicks_first := v_firstValue .processorValueSystemCpuLoadTicks[3] + v_firstValue .processorValueSystemCpuLoadTicks[4];
  var integer v_idleTicks_last := v_lastValue.processorValueSystemCpuLoadTicks[3] + v_lastValue.processorValueSystemCpuLoadTicks[4];
  var float v_cpuUsage := int2float(((v_totalTicks_last-v_totalTicks_first)-(v_idleTicks_last-v_idleTicks_first)))/int2float((v_totalTicks_last-v_totalTicks_first));
  if(v_cpuUsage > p_relativeUpperBound)
  {
    setverdict(fail);
  }
}

// DISK

testcase tc_diskUsageSinceStartGreaterThan(in ServiceInstance p_serviceInstance, in integer p_measurementId, in charstring p_diskId, in float p_relativeUpperBound) 
runs on TestComponent 
{
  ///disk/RAID1/diskValues/1000
  var template HTTPMessage get_request := t_GET_Request( "/disk/"& p_diskId & "/diskValues/" &int2str(p_measurementId));
  var JSONObject result := SendRESTRequest(p_serviceInstance, get_request);
  if(not(ischosen(result.diskValues)))
  {
    stop;
  }
  if(lengthof(result.diskValues) < 2)
  {
    stop;
  }
  setverdict(pass);
  log_debug("Testing if disk usage since start in measurement with id " & int2str(p_measurementId) & " is greater than " & float2str(p_relativeUpperBound));
  var JSONObject.diskValue v_firstValue := result.diskValues[0];
  var JSONObject.diskValue v_lastValue := result.diskValues[lengthof(result.diskValues)-1];
  var integer v_timestamp_first := 	DatestringToRoughlySeconds(v_firstValue.diskValueId.diskValueTimestamp)*1000; 	// convert to ms
  var integer v_timestamp_last := DatestringToRoughlySeconds(v_lastValue.diskValueId.diskValueTimestamp)*1000;		// convert to ms
  var integer v_transferTime_first := v_firstValue.diskValueTransferTime;
  var integer v_transferTime_last := v_lastValue.diskValueTransferTime;
  var float v_diskUsage := int2float(v_transferTime_last-v_transferTime_first)/int2float(v_timestamp_last-v_timestamp_first);
  if(v_diskUsage > p_relativeUpperBound)
  {
    setverdict(fail);
  }
}

// PROCESSES

testcase tc_processMemoryUsageGreaterThan(in JSONObject p_values, in integer p_memoryTotalSpace, in float p_relativeUpperBound)
runs on TestComponent 
{
  if(not(ischosen(p_values.processValues)))
  {
    stop;
  }
  setverdict(pass);
  
  for(var integer i := 0; i<lengthof(p_values.processValues); i := i+1)
  {

    if((int2float(p_values.processValues[i].processValueResidentSetSize)/int2float(p_memoryTotalSpace)) > p_relativeUpperBound)
    {
      setverdict(fail);
      stop;
    }
  }
}

testcase tc_processMemoryUsageSlopeGreaterThan(in JSONObject p_values, in float p_relativeSlopeUpperBound)
runs on TestComponent 
{
  if(not(ischosen(p_values.processValues)))
  {
    stop;
  }
  if(lengthof(p_values.processValues) < 5)
  {
    stop;
  }
  setverdict(pass);
  var IntegerDictionary v_values := {};
  for(var integer i := 0; i<lengthof(p_values.processValues); i := i+1)
  {
    var KeyValueInteger v_value := 
    { 
    	Key := DatestringToRoughlySeconds(p_values.processValues[i].processValueId.processValueTimestamp)-DatestringToRoughlySeconds(p_values.processValues[0].processValueId.processValueTimestamp),
    	Value := p_values.processValues[i].processValueResidentSetSize
    }
    //log(v_value.Key);
    v_values[i] := v_value;
  }
  var RegressionParameter v_regressionResult := CalculateRegressionInteger(v_values);
  if(v_regressionResult.slopeParameter > p_relativeSlopeUpperBound)
  {
    setverdict(fail);
  }
}

testcase tc_getProcessDataByPid(in ServiceInstance p_serviceInstance, in integer p_measurementId, in integer p_processId, out JSONObject p_result) runs on TestComponent
{
  var template HTTPMessage get_request := t_GET_Request( "/process/" &int2str(p_processId)&"/processValues/" &int2str(p_measurementId));
  p_result := SendRESTRequest(p_serviceInstance,get_request);
  if(not(ischosen(p_result.processValues)))
  {
    stop;
  }
  setverdict(pass);

}
	control
    {
      // ==== CONFIG ====
      timer t0:=5.0;
      const integer c_executionLimit := 5280; // 3 Tage und 16 Stunden
      var integer v_executionCounter := 0;
      var SensorInstances v_sensorInstances;
      var ServiceInstance v_serviceInstance := 
      {
        hostname := "localhost",
        portnumber := 8090
      };
      AddSensor("mpc1493", 10005, v_sensorInstances);
      AddSensor("localhost", 10005, v_sensorInstances);
      AddProcessToSensor(v_sensorInstances[0], "HMSAP.LaytecViewer");
      AddProcessToSensor(v_sensorInstances[0], "HMS.LAYTEC.CONNECT.TOOL");
      AddProcessToSensor(v_sensorInstances[0], "LayTec.DatahubSystemTray");
      AddProcessToSensor(v_sensorInstances[0], "EpiNet-Display");
      AddProcessToSensor(v_sensorInstances[0], "sqlservr");
      AddProcessToSensor(v_sensorInstances[1], "java");

	  // ===== CREATE MEASUREMENT FOR EACH SENSOR AND GET SYSTEM DATA =====
      for(var integer i :=0; i<lengthof(v_sensorInstances); i:=i+1)
      {
        var JSONObject.Measurement v_measurement := {};
        var JSONObject.SystemObject v_measurementSystem := {};
        
        // Create Data and start measurement on service instance
        var verdicttype v_createData := execute(tc_createDataByHostname(
        											v_serviceInstance, 
        											v_sensorInstances[i].hostname, 
        											v_sensorInstances[i].portnumber,
        											v_measurement
        										));
       	// If failed, abort test execution with error
        if(v_createData==none or v_createData==error)
        {
          if(v_createData==none)
          {
            log("Creating dataset by hostname failed. Received empty JSON-Response. Check parameters.");
          }
          else if(v_createData== error)
          {
            log("Received error. Check if webservice is running on the given remote hostname and remote port.");
          }
          stop;
        }
        
        // Query system data of the sensor through service instance
        execute(tc_getMeasurementSystemByMeasurementId(v_serviceInstance, v_measurement.measurementId, v_measurementSystem));
        v_sensorInstances[i].measurement := v_measurement;
        v_sensorInstances[i].measurementSystem := v_measurementSystem;

        // ==== CREATE PROCESSES, so they will be tracked by the service instance ====
        var JSONObject.Processes v_allProcesses := {};
        for(var integer j := 0; j<lengthof(v_sensorInstances[i].measurementProcesses); j := j+1)
        {
          var JSONObject.Process v_currentProcess := v_sensorInstances[i].measurementProcesses[j]; 	
          var JSONObject.Processes v_currentProcesses := {};										
          execute(tc_createProcessesWithMeasurementId(
          	v_serviceInstance,
          	v_sensorInstances[i].measurement.measurementId, 
          	v_currentProcess, 
          	v_currentProcesses));
          for(var integer k := 0; k<lengthof(v_currentProcesses); k := k+1)
          {
            v_allProcesses[lengthof(v_allProcesses)] := v_currentProcesses[k];
          }
        }
        v_sensorInstances[i].measurementProcesses := v_allProcesses;
      }
      //=====EXECUTE TESTCASES REPEATEDLY=====
      label startTestcases;
      
      for(var integer i:=0; i<lengthof(v_sensorInstances); i:= i+1)
      {
        //=====MEMORY USAGE====
        execute
        (
        	tc_memoryAvailableLowerThan(
        		v_serviceInstance,
        		v_sensorInstances[i].measurement.measurementId, 
        		v_sensorInstances[i].measurementSystem.systemHardware.hardwareMemory.memoryTotalSpace, 
        		0.20
      		)
        );
        
        //====CPU USAGE=====
        execute
        (
        	tc_processorUsageSinceStartGreaterThan(
        		v_serviceInstance,
        		v_sensorInstances[i].measurement.measurementId, 
        		v_sensorInstances[i].measurementSystem.systemHardware.hardwareProcessor.processorId, 
        		0.80
      		)
        );
        
        //====DISK USAGE====
        execute
        (
        	tc_diskUsageSinceStartGreaterThan(
        		v_serviceInstance,
        		v_sensorInstances[i].measurement.measurementId, 
        		v_sensorInstances[i].measurementSystem.systemHardware.hardwareDisks[0].diskSerialNumber, 
        		0.80
      		)
        );

        //====PROCESS TESTCASES ====
        var JSONObject.Processes v_processes :=  v_sensorInstances[i].measurementProcesses;
        for(var integer j := 0; j<lengthof(v_processes); j:= j+1)
        {
          // GET DATA FOR EACH PROCESS
          var JSONObject v_values;
          execute
          (
          	tc_getProcessDataByPid
          	(
          		v_serviceInstance,
          		v_sensorInstances[i].measurement.measurementId,
          		v_processes[j].processId,
          		v_values          		
          	)
          )
          // CHECK PROCESS MEMORY USAGE GREATER THAN 20%
          log_debug(
          	"Testing if process memory usage in measurement with id " & int2str(v_sensorInstances[i].measurement.measurementId) 
          	& " for the process "& v_processes[j].processName & " with pid " & int2str(v_processes[j].processPid) & " overstepped 20%");
          execute
          (
          	tc_processMemoryUsageGreaterThan
          	(
          		v_values,
          		v_sensorInstances[i].measurementSystem.systemHardware.hardwareMemory.memoryTotalSpace,
          		0.20
          	)
          )
          // CHECK TREND DETECTION AT THE END FOR PROCESS MEMORY USAGE, FAIL WHEN LEAK >173 Bytes/s (~100 MB / week)
          
          if(v_executionCounter > 5)
          {
            log_debug(
          	"Testing if process memory usage trend in measurement with id " & int2str(v_sensorInstances[i].measurement.measurementId) 
          	& " for the process "& v_processes[j].processName & " with pid " & int2str(v_processes[j].processPid) & " overstepped 346 bytes/s");
            execute
          	(
            	tc_processMemoryUsageSlopeGreaterThan
            	(
            		v_values,
            		346.0
            	)
          	)
          }
        }
      }
      v_executionCounter := v_executionCounter + 1;
      if(v_executionCounter < c_executionLimit){
        t0.start(60.0);
      	t0.timeout;
        goto startTestcases;
      }
      for(var integer i := 0; i<lengthof(v_sensorInstances); i := i+1)
      {
        execute(tc_stopMeasurementByMeasurementId(v_serviceInstance, v_sensorInstances[i].measurement.measurementId));
      }
    }
}

